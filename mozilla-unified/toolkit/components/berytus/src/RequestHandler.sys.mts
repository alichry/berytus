/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

// This file is automatically generated; do not edit.
import type { IUnderlyingRequestHandler, ResponseContext, PreliminaryRequestContext, GetSigningKeyArgs, GetCredentialsMetadataArgs, RequestContext, GenerateKeyExchangeParametersArgs, EnableEndToEndEncryptionArgs, ApproveOperationArgs, RequestContextWithOperation, UpdateMetadataArgs, ApproveTransitionToAuthOpArgs, AddFieldArgs, RejectFieldValueArgs, ApproveChallengeRequestArgs, AbortChallengeArgs, CloseChallengeArgs, RespondToChallengeMessageArgs, IPublicRequestHandler, RequestHandler } from './types';
export class IsolatedRequestHandler implements IUnderlyingRequestHandler {
    #impl: IUnderlyingRequestHandler;
    manager: IUnderlyingRequestHandler["manager"];
    channel: IUnderlyingRequestHandler["channel"];
    login: IUnderlyingRequestHandler["login"];
    accountCreation: IUnderlyingRequestHandler["accountCreation"];
    accountAuthentication: IUnderlyingRequestHandler["accountAuthentication"];
    constructor(impl: IUnderlyingRequestHandler) {
        this.#impl = impl;
        const self = this;
        this.manager = {
            async getSigningKey(context: PreliminaryRequestContext & ResponseContext<"manager", "getSigningKey">, args: GetSigningKeyArgs): Promise<void> {
                try {
                    await self.preCall("manager", "getSigningKey", { context, args });
                } catch (e) {
                    context.response.reject(e);
                    return;
                }
                const wrappedResponseCtx: ResponseContext<"manager", "getSigningKey"> = {
                    response: {
                        async resolve(val: Parameters<ResponseContext<"manager", "getSigningKey">["response"]["resolve"]>[0]) {
                            try {
                                await self.preResolve("manager", "getSigningKey", val)
                            } catch (e: any) {
                                context.response.reject(e);
                                throw new Error(e.reason || "ResolutionFailure");
                            }
                            context.response.resolve(val);
                        },
                        async reject(val: unknown) {
                            try {
                                await self.preReject("manager", "getSigningKey", val);
                            } catch (e) {
                                context.response.reject(e);
                                throw e;
                            }
                            context.response.reject(val);
                        }
                    }
                };
                try {
                    await self.#impl.manager.getSigningKey({
                        ...context,
                        ...wrappedResponseCtx
                    }, args);
                } catch (e) {
                    self.handleUnexpectedException(
                        "manager",
                        "getSigningKey",
                        context.response,
                        e
                    );
                    return;
                }
            },
            async getCredentialsMetadata(context: PreliminaryRequestContext & ResponseContext<"manager", "getCredentialsMetadata">, args: GetCredentialsMetadataArgs): Promise<void> {
                try {
                    await self.preCall("manager", "getCredentialsMetadata", { context, args });
                } catch (e) {
                    context.response.reject(e);
                    return;
                }
                const wrappedResponseCtx: ResponseContext<"manager", "getCredentialsMetadata"> = {
                    response: {
                        async resolve(val: Parameters<ResponseContext<"manager", "getCredentialsMetadata">["response"]["resolve"]>[0]) {
                            try {
                                await self.preResolve("manager", "getCredentialsMetadata", val)
                            } catch (e: any) {
                                context.response.reject(e);
                                throw new Error(e.reason || "ResolutionFailure");
                            }
                            context.response.resolve(val);
                        },
                        async reject(val: unknown) {
                            try {
                                await self.preReject("manager", "getCredentialsMetadata", val);
                            } catch (e) {
                                context.response.reject(e);
                                throw e;
                            }
                            context.response.reject(val);
                        }
                    }
                };
                try {
                    await self.#impl.manager.getCredentialsMetadata({
                        ...context,
                        ...wrappedResponseCtx
                    }, args);
                } catch (e) {
                    self.handleUnexpectedException(
                        "manager",
                        "getCredentialsMetadata",
                        context.response,
                        e
                    );
                    return;
                }
            },
        };
        this.channel = {
            async generateKeyExchangeParameters(context: RequestContext & ResponseContext<"channel", "generateKeyExchangeParameters">, args: GenerateKeyExchangeParametersArgs): Promise<void> {
                try {
                    await self.preCall("channel", "generateKeyExchangeParameters", { context, args });
                } catch (e) {
                    context.response.reject(e);
                    return;
                }
                const wrappedResponseCtx: ResponseContext<"channel", "generateKeyExchangeParameters"> = {
                    response: {
                        async resolve(val: Parameters<ResponseContext<"channel", "generateKeyExchangeParameters">["response"]["resolve"]>[0]) {
                            try {
                                await self.preResolve("channel", "generateKeyExchangeParameters", val)
                            } catch (e: any) {
                                context.response.reject(e);
                                throw new Error(e.reason || "ResolutionFailure");
                            }
                            context.response.resolve(val);
                        },
                        async reject(val: unknown) {
                            try {
                                await self.preReject("channel", "generateKeyExchangeParameters", val);
                            } catch (e) {
                                context.response.reject(e);
                                throw e;
                            }
                            context.response.reject(val);
                        }
                    }
                };
                try {
                    await self.#impl.channel.generateKeyExchangeParameters({
                        ...context,
                        ...wrappedResponseCtx
                    }, args);
                } catch (e) {
                    self.handleUnexpectedException(
                        "channel",
                        "generateKeyExchangeParameters",
                        context.response,
                        e
                    );
                    return;
                }
            },
            async enableEndToEndEncryption(context: RequestContext & ResponseContext<"channel", "enableEndToEndEncryption">, args: EnableEndToEndEncryptionArgs): Promise<void> {
                try {
                    await self.preCall("channel", "enableEndToEndEncryption", { context, args });
                } catch (e) {
                    context.response.reject(e);
                    return;
                }
                const wrappedResponseCtx: ResponseContext<"channel", "enableEndToEndEncryption"> = {
                    response: {
                        async resolve(val: Parameters<ResponseContext<"channel", "enableEndToEndEncryption">["response"]["resolve"]>[0]) {
                            try {
                                await self.preResolve("channel", "enableEndToEndEncryption", val)
                            } catch (e: any) {
                                context.response.reject(e);
                                throw new Error(e.reason || "ResolutionFailure");
                            }
                            context.response.resolve(val);
                        },
                        async reject(val: unknown) {
                            try {
                                await self.preReject("channel", "enableEndToEndEncryption", val);
                            } catch (e) {
                                context.response.reject(e);
                                throw e;
                            }
                            context.response.reject(val);
                        }
                    }
                };
                try {
                    await self.#impl.channel.enableEndToEndEncryption({
                        ...context,
                        ...wrappedResponseCtx
                    }, args);
                } catch (e) {
                    self.handleUnexpectedException(
                        "channel",
                        "enableEndToEndEncryption",
                        context.response,
                        e
                    );
                    return;
                }
            },
            async closeChannel(context: RequestContext & ResponseContext<"channel", "closeChannel">): Promise<void> {
                try {
                    await self.preCall("channel", "closeChannel", { context });
                } catch (e) {
                    context.response.reject(e);
                    return;
                }
                const wrappedResponseCtx: ResponseContext<"channel", "closeChannel"> = {
                    response: {
                        async resolve(val: Parameters<ResponseContext<"channel", "closeChannel">["response"]["resolve"]>[0]) {
                            try {
                                await self.preResolve("channel", "closeChannel", val)
                            } catch (e: any) {
                                context.response.reject(e);
                                throw new Error(e.reason || "ResolutionFailure");
                            }
                            context.response.resolve(val);
                        },
                        async reject(val: unknown) {
                            try {
                                await self.preReject("channel", "closeChannel", val);
                            } catch (e) {
                                context.response.reject(e);
                                throw e;
                            }
                            context.response.reject(val);
                        }
                    }
                };
                try {
                    await self.#impl.channel.closeChannel({
                        ...context,
                        ...wrappedResponseCtx
                    }, );
                } catch (e) {
                    self.handleUnexpectedException(
                        "channel",
                        "closeChannel",
                        context.response,
                        e
                    );
                    return;
                }
            },
        };
        this.login = {
            async approveOperation(context: RequestContext & ResponseContext<"login", "approveOperation">, args: ApproveOperationArgs): Promise<void> {
                try {
                    await self.preCall("login", "approveOperation", { context, args });
                } catch (e) {
                    context.response.reject(e);
                    return;
                }
                const wrappedResponseCtx: ResponseContext<"login", "approveOperation"> = {
                    response: {
                        async resolve(val: Parameters<ResponseContext<"login", "approveOperation">["response"]["resolve"]>[0]) {
                            try {
                                await self.preResolve("login", "approveOperation", val)
                            } catch (e: any) {
                                context.response.reject(e);
                                throw new Error(e.reason || "ResolutionFailure");
                            }
                            context.response.resolve(val);
                        },
                        async reject(val: unknown) {
                            try {
                                await self.preReject("login", "approveOperation", val);
                            } catch (e) {
                                context.response.reject(e);
                                throw e;
                            }
                            context.response.reject(val);
                        }
                    }
                };
                try {
                    await self.#impl.login.approveOperation({
                        ...context,
                        ...wrappedResponseCtx
                    }, args);
                } catch (e) {
                    self.handleUnexpectedException(
                        "login",
                        "approveOperation",
                        context.response,
                        e
                    );
                    return;
                }
            },
            async closeOpeation(context: RequestContextWithOperation & ResponseContext<"login", "closeOpeation">): Promise<void> {
                try {
                    await self.preCall("login", "closeOpeation", { context });
                } catch (e) {
                    context.response.reject(e);
                    return;
                }
                const wrappedResponseCtx: ResponseContext<"login", "closeOpeation"> = {
                    response: {
                        async resolve(val: Parameters<ResponseContext<"login", "closeOpeation">["response"]["resolve"]>[0]) {
                            try {
                                await self.preResolve("login", "closeOpeation", val)
                            } catch (e: any) {
                                context.response.reject(e);
                                throw new Error(e.reason || "ResolutionFailure");
                            }
                            context.response.resolve(val);
                        },
                        async reject(val: unknown) {
                            try {
                                await self.preReject("login", "closeOpeation", val);
                            } catch (e) {
                                context.response.reject(e);
                                throw e;
                            }
                            context.response.reject(val);
                        }
                    }
                };
                try {
                    await self.#impl.login.closeOpeation({
                        ...context,
                        ...wrappedResponseCtx
                    }, );
                } catch (e) {
                    self.handleUnexpectedException(
                        "login",
                        "closeOpeation",
                        context.response,
                        e
                    );
                    return;
                }
            },
            async getRecordMetadata(context: RequestContextWithOperation & ResponseContext<"login", "getRecordMetadata">): Promise<void> {
                try {
                    await self.preCall("login", "getRecordMetadata", { context });
                } catch (e) {
                    context.response.reject(e);
                    return;
                }
                const wrappedResponseCtx: ResponseContext<"login", "getRecordMetadata"> = {
                    response: {
                        async resolve(val: Parameters<ResponseContext<"login", "getRecordMetadata">["response"]["resolve"]>[0]) {
                            try {
                                await self.preResolve("login", "getRecordMetadata", val)
                            } catch (e: any) {
                                context.response.reject(e);
                                throw new Error(e.reason || "ResolutionFailure");
                            }
                            context.response.resolve(val);
                        },
                        async reject(val: unknown) {
                            try {
                                await self.preReject("login", "getRecordMetadata", val);
                            } catch (e) {
                                context.response.reject(e);
                                throw e;
                            }
                            context.response.reject(val);
                        }
                    }
                };
                try {
                    await self.#impl.login.getRecordMetadata({
                        ...context,
                        ...wrappedResponseCtx
                    }, );
                } catch (e) {
                    self.handleUnexpectedException(
                        "login",
                        "getRecordMetadata",
                        context.response,
                        e
                    );
                    return;
                }
            },
            async updateMetadata(context: RequestContextWithOperation & ResponseContext<"login", "updateMetadata">, args: UpdateMetadataArgs): Promise<void> {
                try {
                    await self.preCall("login", "updateMetadata", { context, args });
                } catch (e) {
                    context.response.reject(e);
                    return;
                }
                const wrappedResponseCtx: ResponseContext<"login", "updateMetadata"> = {
                    response: {
                        async resolve(val: Parameters<ResponseContext<"login", "updateMetadata">["response"]["resolve"]>[0]) {
                            try {
                                await self.preResolve("login", "updateMetadata", val)
                            } catch (e: any) {
                                context.response.reject(e);
                                throw new Error(e.reason || "ResolutionFailure");
                            }
                            context.response.resolve(val);
                        },
                        async reject(val: unknown) {
                            try {
                                await self.preReject("login", "updateMetadata", val);
                            } catch (e) {
                                context.response.reject(e);
                                throw e;
                            }
                            context.response.reject(val);
                        }
                    }
                };
                try {
                    await self.#impl.login.updateMetadata({
                        ...context,
                        ...wrappedResponseCtx
                    }, args);
                } catch (e) {
                    self.handleUnexpectedException(
                        "login",
                        "updateMetadata",
                        context.response,
                        e
                    );
                    return;
                }
            },
        };
        this.accountCreation = {
            async approveTransitionToAuthOp(context: RequestContextWithOperation & ResponseContext<"accountCreation", "approveTransitionToAuthOp">, args: ApproveTransitionToAuthOpArgs): Promise<void> {
                try {
                    await self.preCall("accountCreation", "approveTransitionToAuthOp", { context, args });
                } catch (e) {
                    context.response.reject(e);
                    return;
                }
                const wrappedResponseCtx: ResponseContext<"accountCreation", "approveTransitionToAuthOp"> = {
                    response: {
                        async resolve(val: Parameters<ResponseContext<"accountCreation", "approveTransitionToAuthOp">["response"]["resolve"]>[0]) {
                            try {
                                await self.preResolve("accountCreation", "approveTransitionToAuthOp", val)
                            } catch (e: any) {
                                context.response.reject(e);
                                throw new Error(e.reason || "ResolutionFailure");
                            }
                            context.response.resolve(val);
                        },
                        async reject(val: unknown) {
                            try {
                                await self.preReject("accountCreation", "approveTransitionToAuthOp", val);
                            } catch (e) {
                                context.response.reject(e);
                                throw e;
                            }
                            context.response.reject(val);
                        }
                    }
                };
                try {
                    await self.#impl.accountCreation.approveTransitionToAuthOp({
                        ...context,
                        ...wrappedResponseCtx
                    }, args);
                } catch (e) {
                    self.handleUnexpectedException(
                        "accountCreation",
                        "approveTransitionToAuthOp",
                        context.response,
                        e
                    );
                    return;
                }
            },
            async getUserAttributes(context: RequestContextWithOperation & ResponseContext<"accountCreation", "getUserAttributes">): Promise<void> {
                try {
                    await self.preCall("accountCreation", "getUserAttributes", { context });
                } catch (e) {
                    context.response.reject(e);
                    return;
                }
                const wrappedResponseCtx: ResponseContext<"accountCreation", "getUserAttributes"> = {
                    response: {
                        async resolve(val: Parameters<ResponseContext<"accountCreation", "getUserAttributes">["response"]["resolve"]>[0]) {
                            try {
                                await self.preResolve("accountCreation", "getUserAttributes", val)
                            } catch (e: any) {
                                context.response.reject(e);
                                throw new Error(e.reason || "ResolutionFailure");
                            }
                            context.response.resolve(val);
                        },
                        async reject(val: unknown) {
                            try {
                                await self.preReject("accountCreation", "getUserAttributes", val);
                            } catch (e) {
                                context.response.reject(e);
                                throw e;
                            }
                            context.response.reject(val);
                        }
                    }
                };
                try {
                    await self.#impl.accountCreation.getUserAttributes({
                        ...context,
                        ...wrappedResponseCtx
                    }, );
                } catch (e) {
                    self.handleUnexpectedException(
                        "accountCreation",
                        "getUserAttributes",
                        context.response,
                        e
                    );
                    return;
                }
            },
            async addField(context: RequestContextWithOperation & ResponseContext<"accountCreation", "addField">, args: AddFieldArgs): Promise<void> {
                try {
                    await self.preCall("accountCreation", "addField", { context, args });
                } catch (e) {
                    context.response.reject(e);
                    return;
                }
                const wrappedResponseCtx: ResponseContext<"accountCreation", "addField"> = {
                    response: {
                        async resolve(val: Parameters<ResponseContext<"accountCreation", "addField">["response"]["resolve"]>[0]) {
                            try {
                                await self.preResolve("accountCreation", "addField", val)
                            } catch (e: any) {
                                context.response.reject(e);
                                throw new Error(e.reason || "ResolutionFailure");
                            }
                            context.response.resolve(val);
                        },
                        async reject(val: unknown) {
                            try {
                                await self.preReject("accountCreation", "addField", val);
                            } catch (e) {
                                context.response.reject(e);
                                throw e;
                            }
                            context.response.reject(val);
                        }
                    }
                };
                try {
                    await self.#impl.accountCreation.addField({
                        ...context,
                        ...wrappedResponseCtx
                    }, args);
                } catch (e) {
                    self.handleUnexpectedException(
                        "accountCreation",
                        "addField",
                        context.response,
                        e
                    );
                    return;
                }
            },
            async rejectFieldValue(context: RequestContextWithOperation & ResponseContext<"accountCreation", "rejectFieldValue">, args: RejectFieldValueArgs): Promise<void> {
                try {
                    await self.preCall("accountCreation", "rejectFieldValue", { context, args });
                } catch (e) {
                    context.response.reject(e);
                    return;
                }
                const wrappedResponseCtx: ResponseContext<"accountCreation", "rejectFieldValue"> = {
                    response: {
                        async resolve(val: Parameters<ResponseContext<"accountCreation", "rejectFieldValue">["response"]["resolve"]>[0]) {
                            try {
                                await self.preResolve("accountCreation", "rejectFieldValue", val)
                            } catch (e: any) {
                                context.response.reject(e);
                                throw new Error(e.reason || "ResolutionFailure");
                            }
                            context.response.resolve(val);
                        },
                        async reject(val: unknown) {
                            try {
                                await self.preReject("accountCreation", "rejectFieldValue", val);
                            } catch (e) {
                                context.response.reject(e);
                                throw e;
                            }
                            context.response.reject(val);
                        }
                    }
                };
                try {
                    await self.#impl.accountCreation.rejectFieldValue({
                        ...context,
                        ...wrappedResponseCtx
                    }, args);
                } catch (e) {
                    self.handleUnexpectedException(
                        "accountCreation",
                        "rejectFieldValue",
                        context.response,
                        e
                    );
                    return;
                }
            },
        };
        this.accountAuthentication = {
            async approveChallengeRequest(context: RequestContextWithOperation & ResponseContext<"accountAuthentication", "approveChallengeRequest">, args: ApproveChallengeRequestArgs): Promise<void> {
                try {
                    await self.preCall("accountAuthentication", "approveChallengeRequest", { context, args });
                } catch (e) {
                    context.response.reject(e);
                    return;
                }
                const wrappedResponseCtx: ResponseContext<"accountAuthentication", "approveChallengeRequest"> = {
                    response: {
                        async resolve(val: Parameters<ResponseContext<"accountAuthentication", "approveChallengeRequest">["response"]["resolve"]>[0]) {
                            try {
                                await self.preResolve("accountAuthentication", "approveChallengeRequest", val)
                            } catch (e: any) {
                                context.response.reject(e);
                                throw new Error(e.reason || "ResolutionFailure");
                            }
                            context.response.resolve(val);
                        },
                        async reject(val: unknown) {
                            try {
                                await self.preReject("accountAuthentication", "approveChallengeRequest", val);
                            } catch (e) {
                                context.response.reject(e);
                                throw e;
                            }
                            context.response.reject(val);
                        }
                    }
                };
                try {
                    await self.#impl.accountAuthentication.approveChallengeRequest({
                        ...context,
                        ...wrappedResponseCtx
                    }, args);
                } catch (e) {
                    self.handleUnexpectedException(
                        "accountAuthentication",
                        "approveChallengeRequest",
                        context.response,
                        e
                    );
                    return;
                }
            },
            async abortChallenge(context: RequestContextWithOperation & ResponseContext<"accountAuthentication", "abortChallenge">, args: AbortChallengeArgs): Promise<void> {
                try {
                    await self.preCall("accountAuthentication", "abortChallenge", { context, args });
                } catch (e) {
                    context.response.reject(e);
                    return;
                }
                const wrappedResponseCtx: ResponseContext<"accountAuthentication", "abortChallenge"> = {
                    response: {
                        async resolve(val: Parameters<ResponseContext<"accountAuthentication", "abortChallenge">["response"]["resolve"]>[0]) {
                            try {
                                await self.preResolve("accountAuthentication", "abortChallenge", val)
                            } catch (e: any) {
                                context.response.reject(e);
                                throw new Error(e.reason || "ResolutionFailure");
                            }
                            context.response.resolve(val);
                        },
                        async reject(val: unknown) {
                            try {
                                await self.preReject("accountAuthentication", "abortChallenge", val);
                            } catch (e) {
                                context.response.reject(e);
                                throw e;
                            }
                            context.response.reject(val);
                        }
                    }
                };
                try {
                    await self.#impl.accountAuthentication.abortChallenge({
                        ...context,
                        ...wrappedResponseCtx
                    }, args);
                } catch (e) {
                    self.handleUnexpectedException(
                        "accountAuthentication",
                        "abortChallenge",
                        context.response,
                        e
                    );
                    return;
                }
            },
            async closeChallenge(context: RequestContextWithOperation & ResponseContext<"accountAuthentication", "closeChallenge">, args: CloseChallengeArgs): Promise<void> {
                try {
                    await self.preCall("accountAuthentication", "closeChallenge", { context, args });
                } catch (e) {
                    context.response.reject(e);
                    return;
                }
                const wrappedResponseCtx: ResponseContext<"accountAuthentication", "closeChallenge"> = {
                    response: {
                        async resolve(val: Parameters<ResponseContext<"accountAuthentication", "closeChallenge">["response"]["resolve"]>[0]) {
                            try {
                                await self.preResolve("accountAuthentication", "closeChallenge", val)
                            } catch (e: any) {
                                context.response.reject(e);
                                throw new Error(e.reason || "ResolutionFailure");
                            }
                            context.response.resolve(val);
                        },
                        async reject(val: unknown) {
                            try {
                                await self.preReject("accountAuthentication", "closeChallenge", val);
                            } catch (e) {
                                context.response.reject(e);
                                throw e;
                            }
                            context.response.reject(val);
                        }
                    }
                };
                try {
                    await self.#impl.accountAuthentication.closeChallenge({
                        ...context,
                        ...wrappedResponseCtx
                    }, args);
                } catch (e) {
                    self.handleUnexpectedException(
                        "accountAuthentication",
                        "closeChallenge",
                        context.response,
                        e
                    );
                    return;
                }
            },
            async respondToChallengeMessage(context: RequestContextWithOperation & ResponseContext<"accountAuthentication", "respondToChallengeMessage">, args: RespondToChallengeMessageArgs): Promise<void> {
                try {
                    await self.preCall("accountAuthentication", "respondToChallengeMessage", { context, args });
                } catch (e) {
                    context.response.reject(e);
                    return;
                }
                const wrappedResponseCtx: ResponseContext<"accountAuthentication", "respondToChallengeMessage"> = {
                    response: {
                        async resolve(val: Parameters<ResponseContext<"accountAuthentication", "respondToChallengeMessage">["response"]["resolve"]>[0]) {
                            try {
                                await self.preResolve("accountAuthentication", "respondToChallengeMessage", val)
                            } catch (e: any) {
                                context.response.reject(e);
                                throw new Error(e.reason || "ResolutionFailure");
                            }
                            context.response.resolve(val);
                        },
                        async reject(val: unknown) {
                            try {
                                await self.preReject("accountAuthentication", "respondToChallengeMessage", val);
                            } catch (e) {
                                context.response.reject(e);
                                throw e;
                            }
                            context.response.reject(val);
                        }
                    }
                };
                try {
                    await self.#impl.accountAuthentication.respondToChallengeMessage({
                        ...context,
                        ...wrappedResponseCtx
                    }, args);
                } catch (e) {
                    self.handleUnexpectedException(
                        "accountAuthentication",
                        "respondToChallengeMessage",
                        context.response,
                        e
                    );
                    return;
                }
            },
        };
    }
    protected preCall(group: string, method: string, args: unknown) {}
    protected preResolve(group: string, method: string, value: unknown) {}
    protected preReject(group: string, method: string, value: unknown) {}
    protected handleUnexpectedException<G extends keyof RequestHandler, M extends keyof RequestHandler[G]>(group: G, method: M, response: ResponseContext<G, M>["response"], excp: unknown) {
        // TODO(berytus): Define what would be the
        // accepted values to reject a request with.
        console.error("Unexpected exception from secret manager:", excp);
        const err = new Components.Exception(
            "Error sending request to secret manager. "
            + "The secret manager unexpectedly threw an exception "
            + "instead of using the reject callback (RequestType: "
            + `${group}:${String(method)}). Exception: ${excp}`,
            Cr.NS_ERROR_FAILURE
        );
        response.reject(err);
    }
}
interface PreCallInput {
    context: Record<string, unknown>;
    args?: unknown
}
const lazy = {};
ChromeUtils.defineESModuleGetters(lazy, {
    Schemas: "resource://gre/modules/Schemas.sys.mjs"
});


/**
 * Implementation copied from Schemas.sys.mjs's Context
 */
class ValidationContext {
    path: Array<string> = [];
    manifestVersion = 2;
    currentChoices = new Set();
    choicePathIndex = 0;

    matchManifestVersion() {
        return true;
    }
    checkLoadURL(url: string) {
        throw new Error("Method not implemented");
    }
    hasPermission(perm: string) {
        throw new Error("Method not implemented");
    }
    logError(err: string | Error) {
        console.error(err);
    }
    withPath(component: string, callback: (...args: any[]) => any) {
        this.path.push(component);
        try {
            return callback();
        } finally {
            this.path.pop();
        }
    }

    get choicePath() {
        let path = this.path.slice(this.choicePathIndex);
        return path.join(".");
    }


    get currentTarget() {
        return this.path.join(".");
    }

    error(
        errorMessage: string | Function | null,
        choicesMessage: string | Function | undefined = undefined,
        warning: boolean = false
    ): object {
        if (choicesMessage !== null) {
            let { choicePath } = this;
            if (choicePath) {
                choicesMessage = `.${choicePath} must ${typeof choicesMessage === "function" ? choicesMessage() : choicesMessage}`;
            }

            this.currentChoices.add(choicesMessage);
        }

        if (this.currentTarget) {
            let { currentTarget } = this;
            return {
                error: () =>
                    `${warning ? "Warning" : "Error"
                    } processing ${currentTarget}: ${typeof errorMessage === "function" ? errorMessage() : errorMessage}`,
            };
        }
        return { error: errorMessage };
    }

    withChoices(callback: Function): object {
        let { currentChoices, choicePathIndex } = this;

        let choices = new Set();
        this.currentChoices = choices;
        this.choicePathIndex = this.path.length;

        try {
            let result = callback();

            return { result, choices };
        } finally {
            this.currentChoices = currentChoices;
            this.choicePathIndex = choicePathIndex;

            if (choices.size == 1) {
                for (let choice of choices) {
                    currentChoices.add(choice);
                }
            } else if (choices.size) {
                this.error(null, () => {
                    let array = Array.from(choices, (m) => {
                        if (typeof m === "function") {
                            return m();
                        }
                        return m;
                    });
                    let n = array.length - 1;
                    array[n] = `or ${array[n]}`;

                    return `must either [${array.join(", ")}]`;
                });
            }
        }
    }
}

class ResolutionError extends Error {
    reason: string;

    constructor(msg: string, reason: string) {
        super(msg);
        this.reason = reason;
    }

    get name() {
        return "ResolutionError";
    }
}

export class ValidatedRequestHandler extends IsolatedRequestHandler {
    #schema: any;

    constructor(impl: IUnderlyingRequestHandler) {
        // TODO(berytus): ensure impl is conformant
        super(impl);
    }

    #validateValue(
        typeEntry: any,
        value: unknown,
        message: string
    ) {
        const { error } = typeEntry.normalize(
            value,
            new ValidationContext()
        );
        if (error) {
            throw new ResolutionError(
                message,
                (typeof error === "function" ? error() : error)
            );
        }
    }

    protected async preCall(group: string, method: string, input: PreCallInput) {
        const methodType = await this.#getMethodTypeEntry(group, method);
        const { parameters } = methodType;
        if (parameters.length === 0) {
            throw new Error(
                `Berytus Schema's RequestHandler type did not '
                + 'contain parameters for ${group}:${method}.`
            );
        }
        const message = `Malformed input passed to the request handler's `
            + `${group}:${method} method. Reason:`;

        this.#validateValue(
            parameters[0].type,
            input.context,
            message
        );
        if (parameters[1]) {
            this.#validateValue(
                parameters[1].type,
                input.args,
                message
            );
        }
        await super.preCall(group, method, input);
    }

    protected async preResolve(group: string, method: string, value: unknown) {
        const resultType = await this.#getMethodResultTypeEntry(group, method);
        this.#validateValue(
            resultType,
            value,
            `Malformed output passed from the request handler's `
            + `${group}:${method} method. Reason:`
        );
        await super.preResolve(group, method, value);
    }

    protected async preReject(group: string, method: string, value: unknown) {
        // TODO(berytus): validate error value
        await super.preReject(group, method, value);
    }

    async #getMethodResultTypeEntry(group: string, method: string) {
        group = group.charAt(0).toUpperCase() + group.substring(1);
        method = method.charAt(0).toUpperCase() + method.substring(1);
        const schema = await this.#getSchema();
        const id = group + method + "Result"
        let resultType = schema.get(id);
        if (! resultType) {
            throw new Error(
                `Berytus Schema did not contain a "${id}" type.`
            );
        }
        return resultType;
    }

    async #getMethodTypeEntry(group: string, method: string) {
        const schema = await this.#getSchema();
        const requestHandlerType = schema.get("RequestHandler");
        if (! requestHandlerType) {
            throw new Error(
                `Berytus Schema did not contain a "RequestHandler" type.`
            );
        }
        if (! (group in requestHandlerType.properties)) {
            throw new Error(
                `Berytus Schema's RequestHandler type did not contain `
                + ` a property for (group:) ${group}`
            );
        }
        let groupHandlerType = requestHandlerType.properties[group].type;
        if ("reference" in groupHandlerType) {
            groupHandlerType = groupHandlerType.targetType;
        }
        if (! (method in groupHandlerType.properties)) {
            throw new Error(
                `Berytus Schema's RequestHandler.${group} type did not contain `
                + ` a property for (method:) ${method}`
            );
        }
        const methodType = groupHandlerType.properties[method].type;
        return methodType;
    }

    async #getSchema() {
        if (this.#schema) {
            return this.#schema;
        }
        // @ts-ignore: TS did not catch assertion for "lazy"
        await lazy.Schemas.load(
            "chrome://extensions/content/schemas/berytus.json"
        );
        // @ts-ignore: TS did not catch assertion for "lazy"
        this.#schema = lazy.Schemas.getNamespace("berytus");
        return this.#schema;
    }
}
export class SequentialRequestHandler extends ValidatedRequestHandler {

    protected busy: boolean = false;

    protected async preCall(group: string, method: string, input: PreCallInput) {
        if (this.busy) {
            throw new Components.Exception(
                'Refusing to send request to secret manager, '
                + 'an existing request is still pending. '
                + 'make sure to send one request at a time '
                + 'to the secret manager.',
                Cr.NS_ERROR_FAILURE
            );
        }
        this.busy = true;
        await super.preCall(group, method, input);
    }
    protected async preResolve(group: string, method: string, value: unknown) {
        this.busy = false;
        await super.preResolve(group, method, value);
    }
    protected async preReject(group: string, method: string, value: unknown) {
        this.busy = false;
        await super.preReject(group, method, value);
    }
    protected handleUnexpectedException<G extends keyof RequestHandler, M extends keyof RequestHandler[G]>(group: G, method: M, response: ResponseContext<G, M>["response"], excp: unknown) {
        this.busy = false;
        super.handleUnexpectedException(group, method, response, excp);
    }
}

function uuid(): string {
    // @ts-ignore: TODO(berytus): add to index.d.ts
    return Services.uuid
        .generateUUID()
        .toString();
}
export class PublicRequestHandler implements IPublicRequestHandler {
    #impl: IUnderlyingRequestHandler;
    manager: IPublicRequestHandler["manager"];
    channel: IPublicRequestHandler["channel"];
    login: IPublicRequestHandler["login"];
    accountCreation: IPublicRequestHandler["accountCreation"];
    accountAuthentication: IPublicRequestHandler["accountAuthentication"];
    constructor(impl: SequentialRequestHandler) {
        if (!(impl instanceof SequentialRequestHandler)) {
            throw new Error(
                'Cannot construct PublicRequestHandler '
                + 'Expecting request handler to be an '
                + 'instance of SequentialRequestHandler; '
                + 'got otherwise.'
            );
        }
        this.#impl = impl;
        const self = this;
        this.manager = {
            getSigningKey(context: Omit<PreliminaryRequestContext, "request">, args: GetSigningKeyArgs): Promise<ReturnType<RequestHandler["manager"]["getSigningKey"]>> {
                return new Promise<ReturnType<RequestHandler["manager"]["getSigningKey"]>>((_resolve, _reject) => {
                    const responseCtx: ResponseContext<"manager", "getSigningKey"> = {
                        response: {
                            resolve(val: ReturnType<RequestHandler["manager"]["getSigningKey"]>) {
                                _resolve(val);
                            },
                            reject(val: unknown) {
                                _reject(val);
                            }
                        }
                    }
                    const requestCtx = {
                        request: {
                            id: uuid(),
                            type: "Manager_GetSigningKey" as const
                        }
                    };
                    self.#impl.manager.getSigningKey({
                        ...context,
                        ...responseCtx,
                        ...requestCtx
                    }, args);
                })
            },
            getCredentialsMetadata(context: Omit<PreliminaryRequestContext, "request">, args: GetCredentialsMetadataArgs): Promise<ReturnType<RequestHandler["manager"]["getCredentialsMetadata"]>> {
                return new Promise<ReturnType<RequestHandler["manager"]["getCredentialsMetadata"]>>((_resolve, _reject) => {
                    const responseCtx: ResponseContext<"manager", "getCredentialsMetadata"> = {
                        response: {
                            resolve(val: ReturnType<RequestHandler["manager"]["getCredentialsMetadata"]>) {
                                _resolve(val);
                            },
                            reject(val: unknown) {
                                _reject(val);
                            }
                        }
                    }
                    const requestCtx = {
                        request: {
                            id: uuid(),
                            type: "Manager_GetCredentialsMetadata" as const
                        }
                    };
                    self.#impl.manager.getCredentialsMetadata({
                        ...context,
                        ...responseCtx,
                        ...requestCtx
                    }, args);
                })
            },
        };
        this.channel = {
            generateKeyExchangeParameters(context: Omit<RequestContext, "request">, args: GenerateKeyExchangeParametersArgs): Promise<ReturnType<RequestHandler["channel"]["generateKeyExchangeParameters"]>> {
                return new Promise<ReturnType<RequestHandler["channel"]["generateKeyExchangeParameters"]>>((_resolve, _reject) => {
                    const responseCtx: ResponseContext<"channel", "generateKeyExchangeParameters"> = {
                        response: {
                            resolve(val: ReturnType<RequestHandler["channel"]["generateKeyExchangeParameters"]>) {
                                _resolve(val);
                            },
                            reject(val: unknown) {
                                _reject(val);
                            }
                        }
                    }
                    const requestCtx = {
                        request: {
                            id: uuid(),
                            type: "Channel_GenerateKeyExchangeParameters" as const
                        }
                    };
                    self.#impl.channel.generateKeyExchangeParameters({
                        ...context,
                        ...responseCtx,
                        ...requestCtx
                    }, args);
                })
            },
            enableEndToEndEncryption(context: Omit<RequestContext, "request">, args: EnableEndToEndEncryptionArgs): Promise<ReturnType<RequestHandler["channel"]["enableEndToEndEncryption"]>> {
                return new Promise<ReturnType<RequestHandler["channel"]["enableEndToEndEncryption"]>>((_resolve, _reject) => {
                    const responseCtx: ResponseContext<"channel", "enableEndToEndEncryption"> = {
                        response: {
                            resolve(val: ReturnType<RequestHandler["channel"]["enableEndToEndEncryption"]>) {
                                _resolve(val);
                            },
                            reject(val: unknown) {
                                _reject(val);
                            }
                        }
                    }
                    const requestCtx = {
                        request: {
                            id: uuid(),
                            type: "Channel_EnableEndToEndEncryption" as const
                        }
                    };
                    self.#impl.channel.enableEndToEndEncryption({
                        ...context,
                        ...responseCtx,
                        ...requestCtx
                    }, args);
                })
            },
            closeChannel(context: Omit<RequestContext, "request">): Promise<ReturnType<RequestHandler["channel"]["closeChannel"]>> {
                return new Promise<ReturnType<RequestHandler["channel"]["closeChannel"]>>((_resolve, _reject) => {
                    const responseCtx: ResponseContext<"channel", "closeChannel"> = {
                        response: {
                            resolve(val: ReturnType<RequestHandler["channel"]["closeChannel"]>) {
                                _resolve(val);
                            },
                            reject(val: unknown) {
                                _reject(val);
                            }
                        }
                    }
                    const requestCtx = {
                        request: {
                            id: uuid(),
                            type: "Channel_CloseChannel" as const
                        }
                    };
                    self.#impl.channel.closeChannel({
                        ...context,
                        ...responseCtx,
                        ...requestCtx
                    }, );
                })
            },
        };
        this.login = {
            approveOperation(context: Omit<RequestContext, "request">, args: ApproveOperationArgs): Promise<ReturnType<RequestHandler["login"]["approveOperation"]>> {
                return new Promise<ReturnType<RequestHandler["login"]["approveOperation"]>>((_resolve, _reject) => {
                    const responseCtx: ResponseContext<"login", "approveOperation"> = {
                        response: {
                            resolve(val: ReturnType<RequestHandler["login"]["approveOperation"]>) {
                                _resolve(val);
                            },
                            reject(val: unknown) {
                                _reject(val);
                            }
                        }
                    }
                    const requestCtx = {
                        request: {
                            id: uuid(),
                            type: "Login_ApproveOperation" as const
                        }
                    };
                    self.#impl.login.approveOperation({
                        ...context,
                        ...responseCtx,
                        ...requestCtx
                    }, args);
                })
            },
            closeOpeation(context: Omit<RequestContextWithOperation, "request">): Promise<ReturnType<RequestHandler["login"]["closeOpeation"]>> {
                return new Promise<ReturnType<RequestHandler["login"]["closeOpeation"]>>((_resolve, _reject) => {
                    const responseCtx: ResponseContext<"login", "closeOpeation"> = {
                        response: {
                            resolve(val: ReturnType<RequestHandler["login"]["closeOpeation"]>) {
                                _resolve(val);
                            },
                            reject(val: unknown) {
                                _reject(val);
                            }
                        }
                    }
                    const requestCtx = {
                        request: {
                            id: uuid(),
                            type: "Login_CloseOpeation" as const
                        }
                    };
                    self.#impl.login.closeOpeation({
                        ...context,
                        ...responseCtx,
                        ...requestCtx
                    }, );
                })
            },
            getRecordMetadata(context: Omit<RequestContextWithOperation, "request">): Promise<ReturnType<RequestHandler["login"]["getRecordMetadata"]>> {
                return new Promise<ReturnType<RequestHandler["login"]["getRecordMetadata"]>>((_resolve, _reject) => {
                    const responseCtx: ResponseContext<"login", "getRecordMetadata"> = {
                        response: {
                            resolve(val: ReturnType<RequestHandler["login"]["getRecordMetadata"]>) {
                                _resolve(val);
                            },
                            reject(val: unknown) {
                                _reject(val);
                            }
                        }
                    }
                    const requestCtx = {
                        request: {
                            id: uuid(),
                            type: "Login_GetRecordMetadata" as const
                        }
                    };
                    self.#impl.login.getRecordMetadata({
                        ...context,
                        ...responseCtx,
                        ...requestCtx
                    }, );
                })
            },
            updateMetadata(context: Omit<RequestContextWithOperation, "request">, args: UpdateMetadataArgs): Promise<ReturnType<RequestHandler["login"]["updateMetadata"]>> {
                return new Promise<ReturnType<RequestHandler["login"]["updateMetadata"]>>((_resolve, _reject) => {
                    const responseCtx: ResponseContext<"login", "updateMetadata"> = {
                        response: {
                            resolve(val: ReturnType<RequestHandler["login"]["updateMetadata"]>) {
                                _resolve(val);
                            },
                            reject(val: unknown) {
                                _reject(val);
                            }
                        }
                    }
                    const requestCtx = {
                        request: {
                            id: uuid(),
                            type: "Login_UpdateMetadata" as const
                        }
                    };
                    self.#impl.login.updateMetadata({
                        ...context,
                        ...responseCtx,
                        ...requestCtx
                    }, args);
                })
            },
        };
        this.accountCreation = {
            approveTransitionToAuthOp(context: Omit<RequestContextWithOperation, "request">, args: ApproveTransitionToAuthOpArgs): Promise<ReturnType<RequestHandler["accountCreation"]["approveTransitionToAuthOp"]>> {
                return new Promise<ReturnType<RequestHandler["accountCreation"]["approveTransitionToAuthOp"]>>((_resolve, _reject) => {
                    const responseCtx: ResponseContext<"accountCreation", "approveTransitionToAuthOp"> = {
                        response: {
                            resolve(val: ReturnType<RequestHandler["accountCreation"]["approveTransitionToAuthOp"]>) {
                                _resolve(val);
                            },
                            reject(val: unknown) {
                                _reject(val);
                            }
                        }
                    }
                    const requestCtx = {
                        request: {
                            id: uuid(),
                            type: "AccountCreation_ApproveTransitionToAuthOp" as const
                        }
                    };
                    self.#impl.accountCreation.approveTransitionToAuthOp({
                        ...context,
                        ...responseCtx,
                        ...requestCtx
                    }, args);
                })
            },
            getUserAttributes(context: Omit<RequestContextWithOperation, "request">): Promise<ReturnType<RequestHandler["accountCreation"]["getUserAttributes"]>> {
                return new Promise<ReturnType<RequestHandler["accountCreation"]["getUserAttributes"]>>((_resolve, _reject) => {
                    const responseCtx: ResponseContext<"accountCreation", "getUserAttributes"> = {
                        response: {
                            resolve(val: ReturnType<RequestHandler["accountCreation"]["getUserAttributes"]>) {
                                _resolve(val);
                            },
                            reject(val: unknown) {
                                _reject(val);
                            }
                        }
                    }
                    const requestCtx = {
                        request: {
                            id: uuid(),
                            type: "AccountCreation_GetUserAttributes" as const
                        }
                    };
                    self.#impl.accountCreation.getUserAttributes({
                        ...context,
                        ...responseCtx,
                        ...requestCtx
                    }, );
                })
            },
            addField(context: Omit<RequestContextWithOperation, "request">, args: AddFieldArgs): Promise<ReturnType<RequestHandler["accountCreation"]["addField"]>> {
                return new Promise<ReturnType<RequestHandler["accountCreation"]["addField"]>>((_resolve, _reject) => {
                    const responseCtx: ResponseContext<"accountCreation", "addField"> = {
                        response: {
                            resolve(val: ReturnType<RequestHandler["accountCreation"]["addField"]>) {
                                _resolve(val);
                            },
                            reject(val: unknown) {
                                _reject(val);
                            }
                        }
                    }
                    const requestCtx = {
                        request: {
                            id: uuid(),
                            type: "AccountCreation_AddField" as const
                        }
                    };
                    self.#impl.accountCreation.addField({
                        ...context,
                        ...responseCtx,
                        ...requestCtx
                    }, args);
                })
            },
            rejectFieldValue(context: Omit<RequestContextWithOperation, "request">, args: RejectFieldValueArgs): Promise<ReturnType<RequestHandler["accountCreation"]["rejectFieldValue"]>> {
                return new Promise<ReturnType<RequestHandler["accountCreation"]["rejectFieldValue"]>>((_resolve, _reject) => {
                    const responseCtx: ResponseContext<"accountCreation", "rejectFieldValue"> = {
                        response: {
                            resolve(val: ReturnType<RequestHandler["accountCreation"]["rejectFieldValue"]>) {
                                _resolve(val);
                            },
                            reject(val: unknown) {
                                _reject(val);
                            }
                        }
                    }
                    const requestCtx = {
                        request: {
                            id: uuid(),
                            type: "AccountCreation_RejectFieldValue" as const
                        }
                    };
                    self.#impl.accountCreation.rejectFieldValue({
                        ...context,
                        ...responseCtx,
                        ...requestCtx
                    }, args);
                })
            },
        };
        this.accountAuthentication = {
            approveChallengeRequest(context: Omit<RequestContextWithOperation, "request">, args: ApproveChallengeRequestArgs): Promise<ReturnType<RequestHandler["accountAuthentication"]["approveChallengeRequest"]>> {
                return new Promise<ReturnType<RequestHandler["accountAuthentication"]["approveChallengeRequest"]>>((_resolve, _reject) => {
                    const responseCtx: ResponseContext<"accountAuthentication", "approveChallengeRequest"> = {
                        response: {
                            resolve(val: ReturnType<RequestHandler["accountAuthentication"]["approveChallengeRequest"]>) {
                                _resolve(val);
                            },
                            reject(val: unknown) {
                                _reject(val);
                            }
                        }
                    }
                    const requestCtx = {
                        request: {
                            id: uuid(),
                            type: "AccountAuthentication_ApproveChallengeRequest" as const
                        }
                    };
                    self.#impl.accountAuthentication.approveChallengeRequest({
                        ...context,
                        ...responseCtx,
                        ...requestCtx
                    }, args);
                })
            },
            abortChallenge(context: Omit<RequestContextWithOperation, "request">, args: AbortChallengeArgs): Promise<ReturnType<RequestHandler["accountAuthentication"]["abortChallenge"]>> {
                return new Promise<ReturnType<RequestHandler["accountAuthentication"]["abortChallenge"]>>((_resolve, _reject) => {
                    const responseCtx: ResponseContext<"accountAuthentication", "abortChallenge"> = {
                        response: {
                            resolve(val: ReturnType<RequestHandler["accountAuthentication"]["abortChallenge"]>) {
                                _resolve(val);
                            },
                            reject(val: unknown) {
                                _reject(val);
                            }
                        }
                    }
                    const requestCtx = {
                        request: {
                            id: uuid(),
                            type: "AccountAuthentication_AbortChallenge" as const
                        }
                    };
                    self.#impl.accountAuthentication.abortChallenge({
                        ...context,
                        ...responseCtx,
                        ...requestCtx
                    }, args);
                })
            },
            closeChallenge(context: Omit<RequestContextWithOperation, "request">, args: CloseChallengeArgs): Promise<ReturnType<RequestHandler["accountAuthentication"]["closeChallenge"]>> {
                return new Promise<ReturnType<RequestHandler["accountAuthentication"]["closeChallenge"]>>((_resolve, _reject) => {
                    const responseCtx: ResponseContext<"accountAuthentication", "closeChallenge"> = {
                        response: {
                            resolve(val: ReturnType<RequestHandler["accountAuthentication"]["closeChallenge"]>) {
                                _resolve(val);
                            },
                            reject(val: unknown) {
                                _reject(val);
                            }
                        }
                    }
                    const requestCtx = {
                        request: {
                            id: uuid(),
                            type: "AccountAuthentication_CloseChallenge" as const
                        }
                    };
                    self.#impl.accountAuthentication.closeChallenge({
                        ...context,
                        ...responseCtx,
                        ...requestCtx
                    }, args);
                })
            },
            respondToChallengeMessage(context: Omit<RequestContextWithOperation, "request">, args: RespondToChallengeMessageArgs): Promise<ReturnType<RequestHandler["accountAuthentication"]["respondToChallengeMessage"]>> {
                return new Promise<ReturnType<RequestHandler["accountAuthentication"]["respondToChallengeMessage"]>>((_resolve, _reject) => {
                    const responseCtx: ResponseContext<"accountAuthentication", "respondToChallengeMessage"> = {
                        response: {
                            resolve(val: ReturnType<RequestHandler["accountAuthentication"]["respondToChallengeMessage"]>) {
                                _resolve(val);
                            },
                            reject(val: unknown) {
                                _reject(val);
                            }
                        }
                    }
                    const requestCtx = {
                        request: {
                            id: uuid(),
                            type: "AccountAuthentication_RespondToChallengeMessage" as const
                        }
                    };
                    self.#impl.accountAuthentication.respondToChallengeMessage({
                        ...context,
                        ...responseCtx,
                        ...requestCtx
                    }, args);
                })
            },
        };
    }
}