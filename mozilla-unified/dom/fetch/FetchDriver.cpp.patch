--- dom/fetch/FetchDriver.cpp.orig	2025-10-15 22:31:30
+++ dom/fetch/FetchDriver.cpp	2025-11-05 23:16:05
@@ -932,7 +932,12 @@
       }
     }
   }
+
 
+  // NOTE(berytus): Second hook. Must be called
+  // before chan->AsyncOpen
+  NotifyHttpFetchObservers(chan);
+
   // if the preferred alternative data type in InternalRequest is not empty, set
   // the data type on the created channel and also create a
   // AlternativeDataStreamListener to be the stream listener of the channel.
@@ -973,6 +978,39 @@
   // Step 4 onwards of "HTTP Fetch" is handled internally by Necko.
 
   mChannel = chan;
+  return NS_OK;
+}
+
+SafeRefPtr<InternalRequest> FetchDriver::GetRequest() const {
+  return mRequest.clonePtr();
+}
+
+bool FetchDriver::GetChannel(nsIChannel** aChannel) const {
+  if (mChannel) {
+    *aChannel = mChannel;
+    return true;
+  }
+  return false;
+}
+
+nsresult FetchDriver::NotifyHttpFetchObservers(nsCOMPtr<nsIChannel>& aChannel) {
+  NS_ENSURE_TRUE(NS_IsMainThread(), NS_ERROR_NOT_SAME_THREAD);
+  nsresult rv;
+  nsCOMPtr<nsIObserverService> obs = services::GetObserverService();
+  if (NS_WARN_IF(!obs)) {
+    return NS_ERROR_FAILURE;
+  }
+  nsCOMPtr<nsISupports> asSupports = do_QueryInterface(static_cast<nsIStreamListener*>(this));
+  if (NS_WARN_IF(!asSupports)) {
+    return NS_ERROR_FAILURE;
+  }
+  nsCOMPtr<nsIHttpChannel> httpChannel = do_QueryInterface(aChannel);
+  NS_ENSURE_TRUE(httpChannel, NS_ERROR_FAILURE);
+  uint64_t channelId = httpChannel->ChannelId();
+  rv = obs->NotifyObservers(asSupports,
+                            NS_FETCH_DRIVER_HTTP_FETCH_TOPIC,
+                            reinterpret_cast<const char16_t*>(&channelId));
+  NS_ENSURE_SUCCESS(rv, rv);
   return NS_OK;
 }
 
