{"version":3,"file":"static/js/main.js","mappings":"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","sources":["db/Identity.ts","db/db.ts","pagecontext.ts","workers/paths.ts","workers/session-utils.ts","../../../../toolkit/components/berytus/src/types.ts","key-utils.ts","ui/utils/userAttributesLabels.ts","workers/field-utils.ts","workers/pageAction-popup-fix.ts","workers/pageAction-utils.ts","workers/main.ts","utils.ts","../node_modules/do_username/lib/constants.js","../node_modules/do_username/lib/do_username.js","../node_modules/do_username/lib/private_functions.js"],"sourcesContent":["import type { UserAttributeKey } from \"@berytus/types\";\nimport { UserAttribute } from \"./db\";\n\n// Not all users have a website, a profile page, or\n// ... a picture.\nconst optionalKeys = [\"profile\", \"picture\", \"website\"] as const;\nexport function isUserAttributeKeyOptional(key: string): boolean {\n    return optionalKeys.indexOf(\n        key as OptionalUserAttributeKey\n    ) !== -1;\n}\ntype OptionalUserAttributeKey = typeof optionalKeys[number];\n\nexport type UserAttributes = Record<\n    Exclude<UserAttributeKey, OptionalUserAttributeKey>,\n    UserAttribute\n> & Partial<Record<OptionalUserAttributeKey, UserAttribute>>;\n\nexport interface Identity {\n    id: string;\n    userAttributes?: UserAttributes;\n    emailAddress?: string;\n    mobileNumber?: string;\n}\n\nexport const PRIMARY_IDENTITY_ID = \"primary\";","import Dexie, { Table } from 'dexie';\nimport { SingleChange } from './ts-utils';\nimport { Identity, PRIMARY_IDENTITY_ID } from './Identity';\nimport { Picture } from './Picture';\nimport { Channel } from './Channel';\nimport { WebApp } from './WebApp';\nimport type { Request, FieldInfo, FieldValueRejectionReason, RecordMetadata, BerytusSendMessageUnion, PreliminaryRequestContext, BerytusChallengeInfoUnion, UserAttributeKey, WebAppActor, ChannelMetadata, LoginOperationMetadata, UriParams, RequestContext, RequestContextWithOperation, RequestContextWithLoginOperation } from '@berytus/types';\nimport { EBerytusChallengeType } from \"@berytus/enums\";\nimport { BerytusEncryptedPacket } from '@berytus/types-extd';\n\nexport interface Field extends FieldInfo {\n  value: string;\n}\n\nexport interface FieldValueRejection extends FieldValueRejectionReason {\n  fieldId: string;\n  webAppDictatedValue?: Field['value'];\n  previousValues: Array<Field['value']>;\n}\n\nexport interface UserAttribute {\n  id: UserAttributeKey;\n  mimeType?: string;\n  // TODO(berytus): REmove this once we remove ArrayBufferViews.\n  value: string | ArrayBuffer | ArrayBufferView | BerytusEncryptedPacket;\n}\n\nexport interface PutField extends FieldInfo {\n  value: string;\n}\n\nexport interface ChallengeMessage extends Omit<BerytusSendMessageUnion, 'challenge' | 'payload'> {\n  payload: string | string[];\n}\n\nexport type Challenge = BerytusChallengeInfoUnion & {\n  messages: Record<string, ChallengeMessage>;\n  closed?: boolean;\n  abortionReasonCode?: string;\n};\n\nexport type SrpChallenge = Challenge & {\n  type: EBerytusChallengeType.SecureRemotePassword;\n  srpState: {\n    fields: { username: string; password: string };\n    serverPublicKeyHexB?: string;\n    clientPrivateKeyHexa?: string;\n    clientPublicKeyHexA?: string; /* Not really needed in any computation, but good for debugging */\n    salt?: string;\n    clientProof?: string;\n    serverProofValid?: boolean;\n  }\n}\n\nexport type DsChallenge = Challenge & {\n  type: EBerytusChallengeType.DigitalSignature;\n  dsState: {\n    // PEM\n    privateKey: string;\n    nonce?: string;\n    signedMessage?: string;\n  }\n}\n\nexport type RRequiredUserAttributes = Record<UserAttributeKey, boolean>;\nexport type RUserAttributes = Record<UserAttributeKey, UserAttribute>;\n\nexport interface Session {\n  id: string;\n  /**\n   * This is the ExtensionRequestContext. Currently, it holds the active\n   * request and the tabId where the Authentication or Registration session is.\n   */\n  context: PreliminaryRequestContext | RequestContext | RequestContextWithOperation | RequestContextWithLoginOperation;\n  /**\n   * Only set in the MODE_EXTERNAL_WINDOW mode. If set, this is\n   * the tabId of the created window. See session-utils.ts->openWindowOrRedirectTab\n   * This is the tab id that corresponds to the Password Manager (us) -'s\n   * created window for request processing (approve session, select user\n   * attributes, etc). This is not the tab id where the Authentication or\n   * Registration session is.\n   */\n  tabId?: number;\n  channel: ChannelMetadata;\n  operation: LoginOperationMetadata;\n  //sessionInfo: OperationMetadata;\n  requests: Array<Request>;\n  requiredUserAttributes?: RRequiredUserAttributes;\n  userAttributes?: Partial<RUserAttributes>;\n  createFieldOptions?: Array<FieldInfo>;\n  putFields?: Array<PutField>;\n  fields?: Array<Field>;\n  rejectedFieldValues?: Array<FieldValueRejection>;\n  metadata: RecordMetadata;\n  createdAccountId?: string;\n  transitionedFromSessionId?: string;\n  /**\n   * Auth session attributes.\n   * TODO: Separate the registration session attributes\n   * from the auth ones\n   */\n  selectedAccountId?: string;\n  challenges?: Record<string, Challenge | SrpChallenge | DsChallenge>;\n  /**\n   * Numeric version of the record. This is used by React Components that expects\n   * a newer version. This is helpful when the background script opens a popup,\n   * but without waiting until the record has been updated. The React Component\n   * expects a record after a specific 'version' where this attribute indicates.\n   */\n  version: number;\n  saved?: boolean;\n  closed?: boolean;\n}\n\nexport interface Account {\n    id: string;\n    registrationUri: UriParams;\n    webAppActor: WebAppActor;\n    userAttributes: Partial<Record<UserAttributeKey, UserAttribute>>;\n    fields: Array<Field>;\n    date: string;\n    metadata: RecordMetadata;\n}\n\nexport interface Settings {\n  seamless: { signup: boolean; login: boolean };\n}\n\nexport const PRIMARY_SETTINGS_ID = \"primary\";\n\nexport interface PendingRequest {\n  id: string;\n  url: string;\n  tabId: number;\n}\n\nexport class SecretDexie extends Dexie {\n  // 'friends' is added by dexie when declaring the stores()\n  // We just tell the typing system this is the case\n  accounts!: Table<Account>;\n  sessions!: Table<Session>;\n  identity!: Table<Identity>;\n  picture!: Table<Picture>;\n  channel!: Table<Channel>;\n  webApp!: Table<WebApp>;\n  pendingRequests!: Table<PendingRequest>;\n  protected settings!: Table<Settings & { id: string }>;\n\n  constructor() {\n    super('secret*');\n    this.version(1).stores({\n      accounts: 'id',\n      sessions: 'id',\n      identity: 'id',\n      settings: 'id',\n      picture: 'filename',\n      channel: 'id',\n      webAppKey: '++id, ed25519Key',\n      pendingRequests: 'id'\n    });\n    this.on('ready', async (dexieDb: Dexie) => {\n      const db = dexieDb as SecretDexie;\n      if ((await db.settings.count()) === 0) {\n        db.settings.add({\n          id: PRIMARY_SETTINGS_ID,\n          seamless: { signup: false, login: false }\n        });\n      }\n      if ((await db.identity.count()) === 0) {\n        db.identity.add({ id: PRIMARY_IDENTITY_ID });\n      }\n    });\n  }\n\n  async getSettings() {\n    const settings = await this.settings.get(PRIMARY_SETTINGS_ID);\n    if (! settings) {\n      throw new Error(\"What?\");\n    }\n    return settings;\n  }\n\n  async updateSettings(change: SingleChange<Settings>) {\n    return this.settings.update(PRIMARY_SETTINGS_ID, {\n      ...change\n    });\n  }\n\n  async getIdentity(): Promise<Identity> {\n    const identity = await this.identity.get(PRIMARY_IDENTITY_ID);\n    if (! identity) {\n      throw new Error('Expecting identity to be set!');\n    }\n    return identity;\n  }\n\n  async savePicture(f: File) {\n    const data = btoa(String.fromCharCode.apply(null, new Uint8Array(await f.arrayBuffer()) as any));\n    const picture = await this.picture.put({\n      filename: f.name,\n      type: f.type,\n      data\n    });\n    return picture;\n  }\n\n  findCorrespondingAccounts(\n    givenActor: WebAppActor,\n    category?: string,\n    version?: number\n  ) {\n    const matchActors = (actorA: WebAppActor, actorB: WebAppActor): boolean => {\n      if (\"ed25519Key\" in actorA) {\n        if (!(\"ed25519Key\" in actorB)) {\n          return false;\n        }\n        return actorA.ed25519Key === actorB.ed25519Key;\n      }\n      if (\"ed25519Key\" in actorB) {\n        return false;\n      }\n      return actorB.originalUri.hostname === actorA.originalUri.hostname;\n    }\n    return this.accounts.filter(\n      ({ webAppActor, metadata }) => {\n        if (! matchActors(givenActor, webAppActor)) {\n          return false;\n        }\n        if (\n          category !== undefined &&\n          category !== metadata.category\n        ) {\n          return false;\n        }\n        if (\n          version !== undefined &&\n          version !== metadata.version\n        ) {\n          return false;\n        }\n        return true;\n      }\n      );\n  }\n\n  pictureToDataUrl(picture: Picture) {\n    return `data:${picture.type};base64,${picture.data}`;\n  }\n}\n\nexport const db = new SecretDexie();\n\n// Just needed to distriibute T when it is a union.\ntype KeyOf<T> = T extends any ? keyof T : never;\nconst Algorithms: Record<number, string> = {\n  [-42]: \"RSAES-OAEP w/ SHA-256\"\n};\n\nexport const fieldOptionValueToString = (optionName: KeyOf<Field['options']>, value: Field['options'][keyof Field['options']]): string => {\n  if (value === undefined) {\n    return \"\";\n  }\n  if (optionName === 'alg') {\n    return Algorithms[Number(value)] || `COSE:${value}`;\n  }\n  return String(value);\n}\n\nexport const isSrpChallenge = (challenge: Challenge): challenge is SrpChallenge => {\n  return \"srpState\" in challenge;\n}\nexport const isDsChallenge = (challenge: Challenge): challenge is DsChallenge => {\n  return \"dsState\" in challenge;\n}\n\n//import('./dummy-data');","export const PAGECONTEXT_WINDOW = \"window\";\nexport const PAGECONTEXT_POPUP = \"popup\";\n\nexport const allowedPageContexts = [\n    PAGECONTEXT_WINDOW,\n    PAGECONTEXT_POPUP\n] as const;\n\nexport type AppPageContext = typeof PAGECONTEXT_WINDOW | typeof PAGECONTEXT_POPUP;\n\nexport const isPopup = (pageContext: string) => {\n    return pageContext === PAGECONTEXT_POPUP;\n}","import { AppPageContext } from \"@root/pagecontext\";\n\nexport const indexUrl =\n    browser?.runtime?.getURL\n        ? browser.runtime.getURL('build/index.html') + \"#\"\n        : 'http://localhost:3000';\n\nexport const paths = { loading: `loading` };\n\nexport const url = (relativePath: string, appPageContext: AppPageContext) => {\n    if (relativePath.startsWith('/')) {\n        return `${indexUrl}/${appPageContext}${relativePath}`;\n    }\n    return `${indexUrl}/${appPageContext}/${relativePath}`;\n}","import { Session, db } from \"@root/db/db\";\nimport { openWindow, redirectTab } from \"./window-utils\";\n\nexport const getSessionRecord = async (sessionId: string) => {\n    const record = await db.sessions.get(sessionId);\n    if (! record) {\n        throw new Error('Unable to find session record by id ' + sessionId);\n    }\n    return record;\n}\n\n/**\n * For each Authentication/Registration session, we create one window.\n * For subsequent requests, we update the tab's URL of the existing window\n * to process the new requests. However, when a request is rejected, the window\n * is closed. As such, the initially created window/tab does not exist anymore.\n * For this, subsequent requests should call `openWindowOrRedirectTab` to either\n * redirect the existing tab (if present) or create a new one. This is only\n * applicable in the MODE_EXTERNAL_WINDOW mode. If a new window/tab is created,\n * we update the session record to reflect the new tab id.\n * @param sessionId\n * @param tabId\n * @param relativePath\n */\nexport const openWindowOrRedirectTab = async (\n    sessionId: string,\n    tabId: number,\n    relativePath: string\n) => {\n    try {\n        await browser.tabs.get(tabId);\n    } catch (e) {\n        // BRTTODO: Check if exception indicates a Tab Not Found error.\n        // no tab. create a window.\n        const window = await openWindow(relativePath);\n        // update session record to store the new tab id.\n        const newTabId = window.tabs![0].id!\n        const change: Pick<Session, 'tabId'> = { tabId: newTabId };\n        await db.sessions.update(sessionId, change);\n        return newTabId;\n    }\n    await redirectTab(tabId, relativePath);\n}","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\nimport type { BerytusChallengeAbortionCode, BerytusChallengeInfoUnion, BerytusFieldOptionsUnion, BerytusFieldUnion, BerytusFieldValue, BerytusFieldValueUnion, BerytusReceiveMessageUnion, BerytusSendMessageUnion, BerytusUserAttributeDefinition, EBerytusChallengeType, EBerytusFieldType } from \"./generated/berytus.web.d.ts\";\n\nexport interface ChannelConstraints {\n    secretManagerPublicKey?: string[];\n    enableEndToEndEncryption: boolean;\n    account?: AccountConstraints;\n}\n\nexport interface PartialAccountIdentity {\n    fieldId: string;\n    fieldValue: string;\n}\n\nexport type AccountIdentity = Array<PartialAccountIdentity>;\n\nexport interface AccountConstraints {\n    category?: string;\n    schemaVersion?: number;\n    identity?: AccountIdentity;\n}\n\nexport interface ChannelMetadata {\n    id: string;\n    constraints: ChannelConstraints;\n    webAppActor: WebAppActor;\n    scmActor: CryptoActor; /* retrieved from getSigningKey */\n}\n\nexport interface UriParams {\n    uri: string;\n    scheme: string;\n    hostname: string;\n    port: number;\n    path: string;\n};\n\nexport interface OriginActor {\n    originalUri: UriParams;\n    currentUri: UriParams;\n}\n\nexport interface CryptoActor {\n    ed25519Key: string;\n}\n\nexport interface Request {\n    id: string;\n    type: string;\n}\n\nexport interface DocumentMetadata {\n    id: number; /* e.g. tabId if sent to extensions */\n    uri: UriParams;\n}\n\nexport enum EOperationStatus {\n    Pending = \"Pending\",\n    Created = \"Created\",\n    Aborted = \"Aborted\",\n    Finished = \"Finished\"\n}\n\nexport enum EOperationType {\n    PendingDeclaration = \"PendingDeclaration\",\n    Registration = \"Registration\",\n    Authentication = \"Authentication\"\n}\n\nexport interface OperationState {}\n\nexport interface OperationMetadata {\n    id: string;\n    type: EOperationType;\n    status: EOperationStatus;\n    /**\n     * State about the operation, e.g.:\n     * { fields:  [BerytusIdentityField, ...], ... }\n     */\n    state: OperationState;\n}\n\nexport interface FieldInfo {\n    id: string;\n    type: EBerytusFieldType;\n    // NOTE(berytus): ValidatedRequestHandler does not\n    // (yet) check if the options is logically conformant.\n    // Alternatively, type FieldInfo = Omit<BerytusFieldUnion, \"value\">\n    // -- however, type-parser would not be able to parse Omit<..>\n    // A better option is to generate *FieldInfoUnion\n    options: BerytusFieldOptionsUnion;\n}\n\nexport interface LoginOperationMetadata extends OperationMetadata {\n    intent: ELoginUserIntent;\n    requestedUserAttributes: RequestedUserAttributes;\n    fields: Record<string, FieldInfo>;\n    challenges: Record<string, BerytusChallengeInfoUnion>;\n}\n\n// TODO(berytus): Addd LoginOperation : *Metadata which includes state\n// about the fields created and so on.\n\nexport interface PreliminaryRequestContext {\n    request: Request;\n    document: DocumentMetadata;\n}\n\nexport interface RequestContext extends PreliminaryRequestContext {\n    channel: ChannelMetadata;\n}\n\nexport interface RequestContextWithOperation extends RequestContext {\n    operation: OperationMetadata;\n}\n\nexport interface RequestContextWithLoginOperation extends RequestContext {\n    operation: LoginOperationMetadata;\n}\n\nexport type CredentialsMetadata = number;\n\nexport enum ELoginUserIntent {\n    PendingDeclaration = \"PendingDeclaration\",\n    Authenticate = \"Authenticate\",\n    Register = \"Register\"\n}\n\nexport type WebAppActor = CryptoActor | OriginActor;\n\nexport interface InitialKeyExchangeParametersDraft {\n    readonly channelId: string; // provided by Berytus\n    readonly webAppX25519Key: string; // provided by the web app\n}\n\n/**\n * What the SCM should return when generating\n * the key exch paramters.\n */\nexport interface PartialKeyExchangeParametersFromScm {\n    scmX25519Key: string;\n    hkdfHash: string; //hash name\n    hkdfSalt: ArrayBuffer;\n    hkdfInfo: ArrayBuffer;\n    aesKeyLength: number; // bits\n}\n\nexport interface KeyExchangeParameters\n    extends InitialKeyExchangeParametersDraft,\n            PartialKeyExchangeParametersFromScm {\n    /**\n     * This is what should be signed.\n     */\n    packet: string;\n}\n\nenum EChallengeType {\n    Identification = \"Identification\",\n    DigitalSignature = \"DigitalSignature\",\n    Password = \"Password\",\n    SecureRemotePassword = \"SecureRemotePassword\",\n    ForeignIdentityOtp = \"ForeignIdentityOtp\"\n}\n\nenum EChallengeStatus {\n    Invalid = \"Invalid\",\n    Pending = \"Pending\",\n    Active = \"Active\",\n    Aborted = \"Aborted\",\n    Sealed = \"Sealed\"\n}\n\nexport interface ChallengeParameters {}\n\nexport interface ChallengeMetadata {\n    readonly id: string;\n    readonly type: EChallengeType;\n    readonly parameters: ChallengeParameters;\n    readonly status: EChallengeStatus;\n}\n\nexport interface ChallengePayload {}\n\nexport interface ChallengeMessage {\n    /**\n     * Unique message name across the challenge.\n     */\n    name: string; // one of EMT{x}\n    payload: ChallengePayload;\n};\n\nexport interface ChallengeMessageResponse {\n    payload: ChallengePayload;\n};\n\nexport interface ChallengeAbortionReason {\n    /**\n     * TODO(berytus): Use string type instead of\n     * ChallengeAbortionCode UnionType until we can\n     * handle unions in schema generation using `choices`\n     */\n    code: string;\n}\n\n// TODO(berytus): Addd ChallengeDetail : ChallengeMetadata which includes state\n// about the fields created and so on.\n\nexport type UserAttributeKey = \"name\" | \"givenName\" | \"familyName\" | \"middleName\" |\n    \"nickname\" |/* \"preferredUsername\" |*/ \"profile\" | \"picture\" |\n    \"website\" |/* \"email\" |*/ \"gender\" | \"birthdate\" | \"zoneinfo\" |\n    \"locale\" |/* \"phoneNumber\" |*/ \"address\" | `custom:${string}`;\n\n\nexport interface UserAttribute extends BerytusUserAttributeDefinition {\n    id: UserAttributeKey;\n};\n\nexport interface RequestedUserAttribute {\n    id: UserAttributeKey;\n    required: boolean;\n}\n\nexport type UserAttributes = Array<UserAttribute>;\nexport type RequestedUserAttributes = Array<RequestedUserAttribute>;\n\nenum EFieldType {\n    Identity = \"Identity\",\n    ForeignIdentity = \"ForeignIdentity\",\n    Password = \"Password\",\n    SecurePassword = \"SecurePassword\",\n    Key = \"Key\"\n};\n\nexport interface BaseFieldMetadata {\n    fieldType: EFieldType;\n    fieldId: string;\n    description?: string;\n}\n\nexport interface FieldValueRejectionReason {\n    code: string;\n}\n\n// TODO(berytus): ERejectionCode should be in the API.\nexport enum ERejectionCode {\n    UnknownReason,\n    GeneralError,\n    NetworkError,\n    UserError,\n    OperationAborted,\n    /* begin challenge trap codes */\n    ChallengeNotSupported,\n    UnexpectedChallengeMessage,\n    InvalidChallengeMessage\n    /* end challenge trap codes */\n}\n\nenum EMetadataProperty {\n    Version = \"Version\",\n    Status = \"Status\",\n    Category = \"Category\",\n    ChangePassUrl = \"ChangePassUrl\"\n};\n\nexport enum EMetadataStatus {\n    Pending = \"Pending\",\n    Created = \"Created\",\n    Retired = \"Retired\",\n};\n\nexport interface RecordMetadata {\n    version: number;\n    status: EMetadataStatus;\n    category: string;\n    changePassUrl: string;\n}\n\n/* Request Arguments */\nexport type GetSigningKeyArgs = { webAppActor: WebAppActor }\nexport type GetCredentialsMetadataArgs = {\n    webAppActor: WebAppActor,\n    channelConstraints: ChannelConstraints,\n    accountConstraints: AccountConstraints\n};\nexport type GenerateKeyExchangeParametersArgs = {\n    paramsDraft: InitialKeyExchangeParametersDraft\n}\nexport type EnableEndToEndEncryptionArgs = {\n    params: KeyExchangeParameters,\n    webAppPacketSignature: ArrayBuffer\n}\nexport type ApproveOperationArgs = {\n    operation: LoginOperationMetadata\n}\nexport type UpdateMetadataArgs = {\n    metadata: RecordMetadata\n}\n\nexport interface UpdateUserAttributesArgs {\n    userAttributes: Array<UserAttribute>;\n};\n\nexport type ApproveTransitionToAuthOpArgs = {\n    newAuthOp: LoginOperationMetadata\n}\nexport type AddFieldArgs = {\n    field: BerytusFieldUnion;\n}\n\n/**\n * The secret manager should resolve with null\n * when a field value was specified in the args.\n */\nexport type AddFieldResult = BerytusFieldValueUnion | null;\n\nexport type RejectFieldValueArgs = {\n    fieldId: string;\n    reason: FieldValueRejectionReason,\n    optionalNewValue?: BerytusFieldValueUnion;\n}\n\n/**\n * The secret manager should resolve with null\n * when a field value was specified in the args.\n */\nexport type RejectFieldResult = BerytusFieldValueUnion | null;\n\nexport type ApproveChallengeRequestArgs = {\n    challenge: BerytusChallengeInfoUnion;\n}\nexport type AbortChallengeArgs = {\n    challenge: BerytusChallengeInfoUnion;\n    reason: BerytusChallengeAbortionCode\n}\nexport type CloseChallengeArgs = {\n    challenge: BerytusChallengeInfoUnion;\n}\nexport type RespondToChallengeMessageArgs = BerytusSendMessageUnion;\nexport type { BerytusSendMessageUnion };\nexport type RespondToChallengeMessageResult = BerytusReceiveMessageUnion;\nexport type { BerytusReceiveMessageUnion };\nexport type { BerytusChallengeInfoUnion };\nexport { EBerytusChallengeType };\n/* Request Arguments */\n\nexport interface RequestHandler {\n    manager: {\n        getSigningKey(\n            context: PreliminaryRequestContext,\n            args: GetSigningKeyArgs\n        ): string;\n        getCredentialsMetadata(\n            context: PreliminaryRequestContext,\n            args: GetCredentialsMetadataArgs\n        ): CredentialsMetadata;\n    };\n    channel: {\n        generateKeyExchangeParameters(\n            context: RequestContext,\n            args: GenerateKeyExchangeParametersArgs\n        ): PartialKeyExchangeParametersFromScm;\n        enableEndToEndEncryption(\n            context: RequestContext,\n            args: EnableEndToEndEncryptionArgs\n        ): ArrayBuffer;\n        closeChannel(context: RequestContext): void;\n    };\n    /**\n     * Common requests between the account creation/registration\n     * operations, grouped under login.\n     */\n    login: {\n        approveOperation(\n            context: RequestContext,\n            args: ApproveOperationArgs\n        ): ELoginUserIntent;\n        closeOperation(\n            context: RequestContextWithOperation\n        ): void;\n        /* Berytus setPasswordUrl/setStatus/setVersion/setCategory: */\n        getRecordMetadata(\n            context: RequestContextWithOperation\n        ): RecordMetadata\n        updateMetadata(\n            context: RequestContextWithOperation,\n            args: UpdateMetadataArgs\n        ): void\n    },\n    accountCreation: {\n        approveTransitionToAuthOp(\n            context: RequestContextWithOperation,\n            args: ApproveTransitionToAuthOpArgs\n        ): void;\n        getUserAttributes(\n            context: RequestContextWithLoginOperation\n        ): UserAttributes;\n        updateUserAttributes(\n            context: RequestContextWithOperation,\n            args: UpdateUserAttributesArgs\n        ): void;\n        addField(\n            context: RequestContextWithLoginOperation,\n            args: AddFieldArgs\n        ): AddFieldResult;\n        rejectFieldValue(\n            context: RequestContextWithLoginOperation,\n            args: RejectFieldValueArgs\n        ): RejectFieldResult;\n    };\n    accountAuthentication: {\n        approveChallengeRequest(\n            context: RequestContextWithOperation,\n            args: ApproveChallengeRequestArgs\n        ): void;\n        abortChallenge(\n            context: RequestContextWithOperation,\n            args: AbortChallengeArgs\n        ): void;\n        closeChallenge(\n            context: RequestContextWithOperation,\n            args: CloseChallengeArgs,\n        ): void;\n        respondToChallengeMessage(\n            context: RequestContextWithLoginOperation,\n            args: RespondToChallengeMessageArgs\n        ): RespondToChallengeMessageResult;\n    }\n}\n\nexport type ResponseContext<G extends keyof RequestHandler, M extends keyof RequestHandler[G]> = {\n    response:\n        RequestHandler[G][M] extends (...args: any[]) => any\n        ? {\n            resolve: (val: ReturnType<RequestHandler[G][M]>) => void,\n            reject: (val: unknown) => void\n        }\n        : never\n}\n\nexport type IUnderlyingRequestHandler = {\n    [group in keyof RequestHandler]: {\n        [method in keyof RequestHandler[group]]:\n            RequestHandler[group][method] extends (...args: any[]) => any\n                ? Parameters<RequestHandler[group][method]> extends [infer context, ...infer tail]\n                    ? (context: context & ResponseContext<group,method> , ...rest: tail) => void\n                    : never\n                : never\n    }\n}\n\nexport type IPublicRequestHandler = {\n    [group in keyof RequestHandler]: {\n        [method in keyof RequestHandler[group]]:\n            RequestHandler[group][method] extends (...args: any[]) => any\n                ? Parameters<RequestHandler[group][method]> extends [infer context, ...infer tail]\n                    ?   (context: Omit<context, 'request'>, ...rest: tail) => Promise<ReturnType<RequestHandler[group][method]>>\n                    : never\n                : never\n    }\n}\n\nexport type RequestGroup = keyof RequestHandler;\nexport type RequestType = keyof {\n    [K in RequestGroup as `${Capitalize<K>}_${Capitalize<keyof RequestHandler[K] & string>}`]: true\n}\n\nexport type RequestHandlerFunction<ER extends RequestType> =\n    Uncapitalize<ER> extends `${infer G}_${infer T}`\n        ? G extends RequestGroup\n            ? Uncapitalize<T> extends `${infer M}`\n                ? M extends keyof RequestHandler[G]\n                    ? RequestHandler[G][M]\n                    : never\n                : never\n            : never\n    : never;\n\nexport type RequestHandlerFunctionParameters<ER extends RequestType>\n    = Parameters<RequestHandlerFunction<ER>>;\n\nexport type RequestHandlerFunctionReturnType<ER extends RequestType>\n    = Awaited<ReturnType<RequestHandlerFunction<ER>>>;","export function formatBase64AsPem(str: string, publicKey: boolean = true) {\n    const type = publicKey ? \"PUBLIC\" : \"PRIVATE\"\n    let res = `-----BEGIN ${type} KEY-----\\n`;\n\n    while(str.length > 0) {\n        res += str.substring(0, 64) + '\\n';\n        str = str.substring(64);\n    }\n\n    res = res + `-----END ${type} KEY-----`;\n\n    return res;\n}\nexport function formatSignatureBufToString(signedMessage: ArrayBuffer): string {\n    let hex = ab2base64(signedMessage);\n    let res = \"-----BEGIN CUSTOM SIGNATURE FORMAT -----\\n\";\n\n    while(hex.length > 0) {\n        res += hex.substring(0, 64) + '\\n';\n        hex = hex.substring(64);\n    }\n\n    res += \"----END CUSTOM SIGNATURE FORMAT -----\";\n    return res;\n}\n\nexport function extractPemBase64Body(pemStr: string, publicKey: boolean = true): string {\n    const type = publicKey ? \"PUBLIC\" : \"PRIVATE\"\n    const header = `-----BEGIN ${type} KEY-----\\n`;\n    const footer = `-----END ${type} KEY-----`;\n    if (! pemStr.startsWith(header)) {\n        throw new Error('Key does not start with \"'+header+'\"')\n    }\n    if (! pemStr.endsWith(footer)) {\n        throw new Error('Key does not end with \"'+footer+'\"')\n    }\n    const body = pemStr.substring(header.length, pemStr.length - footer.length);\n    const base64 = body.replace(/\\r?\\n|\\r/g, '');\n    return base64;\n}\n// TODO(berytus): Review this impl\nexport function pemToBuf(str: string, publicKey: boolean = true): ArrayBufferLike {\n    const base64 = extractPemBase64Body(str, publicKey);\n    return str2ab(atob(base64));\n}\n\nexport function bufToPem(buffer: ArrayBuffer, publicKey?: boolean) {\n    return formatBase64AsPem(ab2base64(buffer), publicKey);\n}\n\nexport function ab2str(buffer: ArrayBufferLike) {\n    return String.fromCharCode.apply(null, new Uint8Array(buffer) as any);\n}\n\nexport function str2ab(str: string): ArrayBufferLike {\n    return new TextEncoder().encode(str).buffer;\n}\n\nexport function ab2base64(buffer: ArrayBufferLike) {\n    return btoa(ab2str(buffer));\n}\n\nexport function decodeHex(hex: string): ArrayBufferLike {\n    if (hex.startsWith(\"0x\")) {\n        hex = hex.substring(2);\n    }\n    if (hex.length % 2 !== 0) {\n        throw new Error(\"Bad Hex.\");\n    }\n    const bytes = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < hex.length;) {\n        bytes[i / 2] = Number.parseInt(hex.slice(i, i += 2), 16);\n    }\n    return bytes.buffer;\n}\n\nexport async function privateKeyBufToPublicKeyBuf(privateKeyBuf: ArrayBufferLike): Promise<ArrayBuffer> {\n    const privateKey = await window.crypto.subtle.importKey(\n        \"pkcs8\",\n        privateKeyBuf instanceof ArrayBuffer\n            ? privateKeyBuf\n            : new Uint8Array(privateKeyBuf),\n        {\n            name: \"RSA-OAEP\",\n            hash: {name: \"SHA-256\"}\n        },\n        true,\n        [\"decrypt\"]\n    );\n    const privateKeyJwk = await window.crypto.subtle.exportKey('jwk', privateKey);\n    const publicKey = await window.crypto.subtle.importKey(\n        'jwk',\n        {\n            n: privateKeyJwk.n,\n            e: privateKeyJwk.e,\n            alg: privateKeyJwk.alg,\n            kty: privateKeyJwk.kty,\n        },\n        {\n            name: \"RSA-OAEP\",\n            hash: { name: \"SHA-256\" }\n        },\n        true,\n        [\"encrypt\"]\n    );\n    return window.crypto.subtle.exportKey('spki', publicKey);\n}\n\nexport function base64ToArrayBuffer(base64: string): ArrayBuffer {\n    const binaryString = atob(base64);\n    const bytes = new Uint8Array(binaryString.length);\n    for (let i = 0; i < binaryString.length; i++) {\n        bytes[i] = binaryString.charCodeAt(i);\n    }\n    return bytes.buffer;\n}","import type { UserAttributeKey } from \"@berytus/types\";\n\nexport const userAttributesLabels: Record<\n    UserAttributeKey, string\n> = {\n    \"name\": \"Full name\",\n    \"givenName\": \"First name\",\n    \"middleName\": \"Middle name\",\n    \"familyName\": \"Family name\",\n    \"nickname\": \"Nickname\",\n    \"gender\": \"Gender\",\n    \"birthdate\": \"Birthdate\",\n    \"locale\": \"Locale\",\n    \"address\": \"Address\",\n    \"profile\": \"Profile URL\",\n    \"picture\": \"Picture\",\n    \"website\": \"Website URL\",\n    \"zoneinfo\": \"Zoneinfo\"\n}","import { ab2base64 } from \"@root/key-utils\";\nimport type { ArrayBufferOrBerytusEncryptedPacket, BerytusEncryptedPacket, BerytusFieldUnion } from \"@berytus/types-extd\";\n\nexport const stringifyEncryptedPacket = (value: BerytusEncryptedPacket) => {\n    const parameters: Record<string, string | number | boolean | undefined> = {};\n    (Object.keys(value.parameters) as Array<keyof typeof value.parameters>).forEach(key => {\n        const prop = value.parameters[key];\n        if (prop === undefined || typeof prop === \"string\" || typeof prop === \"number\" || typeof prop === \"boolean\") {\n            parameters[key] = prop;\n            return;\n        }\n        if (prop instanceof ArrayBuffer) {\n            parameters[key] = ab2base64(prop);\n            return;\n        }\n        // TODO(berytus): Remove this when ArrayBufferViews are removed\n        parameters[key] = ab2base64(prop.buffer);\n    })\n    return JSON.stringify({\n        ciphertext: ab2base64(value.ciphertext),\n        parameters\n    })\n}\n\nexport const stringifyArrayBufferOrEncryptedPacket = (value: ArrayBufferOrBerytusEncryptedPacket) => {\n    if (value instanceof ArrayBuffer) {\n        return ab2base64(value);\n    }\n    return stringifyEncryptedPacket(value);\n}\n\nexport const stringifyFieldValue = (fieldValue: BerytusFieldUnion['value']) =>  {\n    if (typeof fieldValue === \"string\") {\n        return fieldValue;\n    }\n    if (fieldValue === null) {\n        return \"\";\n    }\n    if (\"salt\" in fieldValue) {\n        return JSON.stringify({\n            salt: stringifyArrayBufferOrEncryptedPacket(fieldValue.salt),\n            verifier: stringifyArrayBufferOrEncryptedPacket(fieldValue.verifier)\n        })\n    }\n    if (\"privateKey\" in fieldValue) {\n        return stringifyArrayBufferOrEncryptedPacket(fieldValue.privateKey);\n    }\n    if (\"publicKey\" in fieldValue) {\n        return stringifyArrayBufferOrEncryptedPacket(fieldValue.publicKey);\n    }\n    return stringifyArrayBufferOrEncryptedPacket(fieldValue);\n}","/**\n * browser.pageAction.openPopup() is a nuanced API.\n * - Cannot be called unless a user action status is set; fair.\n * - Would close a popup if it's open; making things difficult.\n *      - And, it's impossible to check whether the popup is already\n *        open without losing the user action status.\n * => Therefore, calling browser.pageAction.openPopup() whenever\n *    we want the user to resolve a request could potentially close\n *    an already open popup.\n *\n * In Berytus 0.1, I had implemented a WebExtension API for this purpose,\n * called openPageActionPopupIfNecessary (under browser.authrealm).\n * It had enabled extensions to open the popup, if necessary, only when\n * a request is pending and has not been resolved/reject yet. While this is\n * certainly not ideal to deploy for all extensions, it served as a remedy.\n *\n * In Berytus 0.2, I wrote the below code as a workaround without\n * relying on the introduction of a new WebExtensions API. Essentially,\n * the popup should send a message to the background script asking it\n * to resolve/reject the request. Here, the background script would\n * first hide the popup from the tab, ensuring that it is closed,\n * and it cannot be opened by the user, before resolving/rejecting the\n * request. Hence, whenever a new request comes from Berytus, the popup\n * is guaranteed to be closed, and browser.pageAction.openPopup() would\n * certainly open the popup. Sadly, this means that the popup page\n * should not directly call browser.berytus.(resolve/reject)Request.\n */\n\nimport { setPageActionUrlInTab } from \"./pageAction-utils\";\n\ninterface OpenOptions {\n    requestId: string;\n    tabId: number;\n}\n\nexport const openPageActionPopupIfNecessary = async ({ requestId, tabId }: OpenOptions, absolutePath: string) => {\n    browser.pageAction.show(tabId);\n    const prom0 = associateTabIdWithRequest(requestId, tabId);\n    const prom1 = setPageActionUrlInTab(tabId, absolutePath, false);\n    const prom2 = (browser.pageAction as any).openPopup();\n    await prom0;\n    await prom1;\n    await prom2;\n}\n\nconst tabDictKey = (requestId: string) => `tabdict:${requestId}`;\n\nconst associateTabIdWithRequest = async (requestId: string, tabId: number) => {\n    await browser.storage.session.set({\n        [tabDictKey(requestId)]: tabId\n    });\n}\n\nconst getAssociatedTabId = async (requestId: string): Promise<number | undefined> => {\n    const key = tabDictKey(requestId);\n    const res = await browser.storage.session.get(key);\n    return res[key];\n}\n\nconst deleteTabIdAssociation = async (requestId: string): Promise<void> => {\n    await browser.storage.session.remove(tabDictKey(requestId));\n}\n\ntype MessageRequests = {\n    type: \"resolveRequest\" | \"rejectRequest\"\n    data: {\n        requestId: string;\n        value: unknown\n    }\n} /* | ... */\n\nbrowser.runtime.onMessage.addListener(\n    function(request: MessageRequests, sender, sendResponse) {\n        console.log(\"onMessage:\", request, sender)\n        if (sender.id !== \"secretstar@alichry\") {\n            return;\n        }\n        const hide = async () => {\n            const tabId = await getAssociatedTabId(request.data.requestId);\n            if (! tabId) {\n                console.warn(\"secretstar: can't hide popup, tabId undefined.\");\n                return;\n            }\n            try {\n                await Promise.resolve(browser.pageAction.hide(tabId));\n            } catch (e) {\n                console.warn(\"secretstar: error hiding popup:\");\n                console.error(e)\n            } finally {\n                await deleteTabIdAssociation(request.data.requestId);\n            }\n        }\n        const send = async (type: \"resolve\" | \"reject\") => {\n            try {\n                await (\n                    type === \"resolve\"\n                        ? browser.berytus.resolveRequest(request.data.requestId, request.data.value)\n                        : browser.berytus.rejectRequest(request.data.requestId, request.data.value)\n                );\n                console.debug(\"secretstar@alichry: settled request\", request.data.requestId);\n            } catch (e) {\n                console.warn(\"secretstar: error resolving request:\");\n                console.error(e);\n            }\n        }\n        if (request.type === \"resolveRequest\") {\n            hide().then(() => send(\"resolve\"));\n            sendResponse();\n            return;\n        }\n        if (request.type === \"rejectRequest\") {\n            hide().then(() => send(\"reject\"));\n            sendResponse();\n            return;\n        }\n    }\n);","import { PAGECONTEXT_POPUP } from '@root/pagecontext';\nimport { url, paths } from './paths';\n\nexport function setPageActionUrlInTab(\n    tabIdWherePageActionIs: number,\n    path: string,\n    relative = true\n) {\n    return browser.pageAction.setPopup({\n        tabId: tabIdWherePageActionIs,\n        popup: relative\n            ? url(path, PAGECONTEXT_POPUP)\n            : path\n    });\n}\n\nexport function setPageActionToLoadingPage(tabIdWherePageActionIs: number) {\n    return setPageActionUrlInTab(tabIdWherePageActionIs, paths.loading);\n}\n\n/**\n * browser.pageAction.openPopup() has several limitations:\n * 1. It only opens up the page action popup in the selected tab.\n * 2. If the popup is already open, it closes it. Making it difficult\n * to open the popup if necessary.\n * 3. If we wish to highlight the relevant tab where the popup should open,\n * we lose the `user action` status since doing so is asynchronous, and\n * we cannot open the popup unless the correct tab is highlighted.\n * We have created browser.authRealm.openPageActionPopupIfNecessary\n * to open the popup in the relevant tab (the tab belonging to the authRealm\n * session).\n * @param tabIdWherePageActionIs\n */\nexport async function openPageActionInTabId(tabIdWherePageActionIs: number) {\n    const tab = await browser.tabs.get(tabIdWherePageActionIs);\n    await browser.tabs.highlight({ windowId: tab.windowId, tabs: [tab.index] });\n    // Firefox only.\n    (browser.pageAction as any).openPopup();\n}","import { Session, db } from \"@root/db/db\";\nimport { MODE, MODE_EXTERNAL_WINDOW } from \"../env\";\nimport { openWindow } from \"./window-utils\";\nimport { getSessionRecord, openWindowOrRedirectTab } from \"./session-utils\";\nimport { url } from \"./paths\";\nimport { randomPassword } from \"@root/utils\";\nimport { PAGECONTEXT_POPUP } from \"@root/pagecontext\";\nimport { ab2base64 } from \"@root/key-utils\";\nimport { Channel } from \"@root/db/Channel\";\nimport { ERejectionCode, EOperationType, EMetadataStatus, RequestType } from \"@berytus/enums\";\nimport type { PreliminaryRequestContext } from \"@berytus/types\";\nimport { userAttributesLabels } from \"@root/ui/utils/userAttributesLabels\";\nimport { stringifyArrayBufferOrEncryptedPacket, stringifyEncryptedPacket } from \"./field-utils\";\nimport { openPageActionPopupIfNecessary } from \"./pageAction-popup-fix\";\n\nconsole.debug(\"secretstar(bg): loaded\");\n\nconst plainContext = (context: PreliminaryRequestContext) => {\n    return {\n        ...context,\n        response: undefined,\n    }\n}\n\nasync function printSessionForSimiluationPrep(\n    phase: RequestType | `${RequestType}:${string}`,\n    sessionId: string\n) {\n    // const session = await getSessionRecord(sessionId);\n    // console.log('simulate:', JSON.stringify({\n    //     phase, session\n    // }, null, 2));\n}\n\nasync function printSessionWithChannelForSimulationPrep(\n    phase: RequestType,\n    sessionId: string\n) {\n    // const session = await getSessionRecord(sessionId);\n    // const channel = await db.channel.get(session.channel.id);\n    // if (! channel) {\n    //     throw new Error('Cant find channel to print simulation prep');\n    // }\n    // console.log('simulate', phase, JSON.stringify({\n    //     session,\n    //     channel\n    // }, null, 2));\n}\n\nasync function showUi(\n    context: PreliminaryRequestContext,\n    sessionId: string,\n    relativePath: string,\n    sessionRecordPromise?: ReturnType<typeof getSessionRecord>\n) {\n    if (MODE === MODE_EXTERNAL_WINDOW) {\n        const { tabId } = await (sessionRecordPromise || getSessionRecord(sessionId));\n        if (! tabId) {\n            console.error('Secret* is in External Mode but session record had no tab id');\n            browser.berytus.rejectRequest(context.request.id, ERejectionCode.GeneralError);\n            return;\n        }\n        await openWindowOrRedirectTab(sessionId, tabId, relativePath);\n        return;\n    }\n    openPageActionPopupIfNecessary(\n        { requestId: context.request.id, tabId: context.document.id },\n        url(relativePath, PAGECONTEXT_POPUP)\n    );\n}\n\nbrowser.berytus.registerRequestHandler({\n    manager: {\n        async getSigningKey(context, args): Promise<void> {\n            const publicKey = \"BRTTODO:SCMEd25519PublicKey\";\n            const privateKey = \"BRTTODO:SCMEd25519PrivateKey\";\n            // BRTTODO: Move base channel creation { id: channelId }\n            // once we have approveChannel()\n            await db.channel.add({\n                id: \"BRTTODO:ChannelID\" + Math.floor(Math.random() * 1000),\n                webAppEd25519Key: \"ed25519Key\" in args.webAppActor\n                    ? args.webAppActor.ed25519Key\n                    : undefined,\n                scmEd25519Key: {\n                    publicKey,\n                    privateKey\n                }\n            });\n            context.response.resolve(publicKey);\n        },\n        async getCredentialsMetadata(context, args): Promise<void> {\n            const accounts = db.findCorrespondingAccounts(\n                args.webAppActor,\n                args.accountConstraints.category,\n                args.accountConstraints.schemaVersion\n            );\n            context.response.resolve(await accounts.count());\n        },\n    },\n    channel: {\n        async generateKeyExchangeParameters(context, args): Promise<void> {\n            const channel = await db.channel.get(context.channel.id);\n            if (! channel) {\n                throw new Error('Unable to find channel by id ' + context.channel.id);\n            }\n            if (! channel.scmEd25519Key) {\n                throw new Error('Expecting our scm ed25519Key to have been genenrated');\n            }\n            if (! channel.webAppEd25519Key) {\n                throw new Error('Expecting webapp ed25519Key to have been given previously');\n            }\n            const salt = new Uint8Array(32);\n            const info = new Uint8Array(16);\n            window.crypto.getRandomValues(salt);\n            window.crypto.getRandomValues(info);\n            // generate X25519Key\n            const scmX25519Key = await window.crypto.subtle.generateKey(\n                {\n                  name: \"X25519\",\n                },\n                true,\n                [\"deriveKey\"],\n              ) as CryptoKeyPair;\n            const params = {\n                aesKeyLength: 256,\n                hkdfHash: \"SHA-256\",\n                hkdfSalt: salt.buffer,\n                hkdfInfo: info.buffer,\n            };\n            const change: Pick<Channel, 'scmX25519Key' | 'webAppX25519Key' | 'params'> = {\n                webAppX25519Key: args.paramsDraft.webAppX25519Key,\n                params: {\n                    aesKeyLength: params.aesKeyLength,\n                    hkdfHash: params.hkdfHash,\n                    hkdfSalt: ab2base64(params.hkdfSalt),\n                    hkdfInfo: ab2base64(params.hkdfInfo)\n                },\n                scmX25519Key: {\n                    privateKey: ab2base64(\n                        await window.crypto.subtle.exportKey(\"pkcs8\", scmX25519Key.privateKey)\n                    ),\n                    publicKey: ab2base64(\n                        await window.crypto.subtle.exportKey(\"spki\", scmX25519Key.publicKey)\n                    )\n                },\n            };\n            await db.channel.update(channel, change);\n            context.response.resolve(\n                {\n                    ...params,\n                    scmX25519Key: ab2base64(\n                        await window.crypto.subtle.exportKey(\"raw\", scmX25519Key.publicKey)\n                    )\n                }\n            );\n        },\n        async enableEndToEndEncryption(context, args): Promise<void> {\n            let window: chrome.windows.Window | undefined = undefined;\n            const relativePath = `enable-e2e/${context.channel.id}/${context.request.id}/${context.request.type}`;\n            if (MODE === MODE_EXTERNAL_WINDOW) {\n                window = await openWindow(relativePath);\n            } else {\n                openPageActionPopupIfNecessary(\n                    { requestId: context.request.id, tabId: context.document.id },\n                    url(relativePath, PAGECONTEXT_POPUP)\n                );\n            }\n            const channel = await db.channel.get(context.channel.id);\n            if (! channel) {\n                throw new Error('Expecting channel to be created');\n            }\n            if (channel.webAppSignature) {\n                throw new Error('Expecting web app signature to be unset, i.e. not set previously.');\n            }\n            const change: Pick<Channel, 'webAppSignature'> = {\n                webAppSignature: ab2base64(args.webAppPacketSignature)\n            };\n            await db.channel.update(channel, change);\n        },\n        closeChannel: function (context): void {\n            context.response.resolve();\n        }\n    },\n    login: {\n        async approveOperation(context, args): Promise<void> {\n            let window: chrome.windows.Window | undefined = undefined;\n            const relativePath = `intent/${args.operation.id}/0`;\n            if (MODE === MODE_EXTERNAL_WINDOW) {\n                window = await openWindow(relativePath);\n            } else {\n                openPageActionPopupIfNecessary(\n                    { requestId: context.request.id, tabId: context.document.id },\n                    url(relativePath, PAGECONTEXT_POPUP)\n                );\n            }\n            await db.sessions.add({\n                id: args.operation.id,\n                requests: [context.request],\n                channel: context.channel,\n                operation: args.operation,\n                context: plainContext(context),\n                tabId: window?.tabs ? window.tabs[0].id : undefined,\n                metadata: {\n                    version: context.channel.constraints.account?.schemaVersion || 0,\n                    status: EMetadataStatus.Pending,\n                    category: context.channel.constraints.account?.category || \"\",\n                    changePassUrl: \"\"\n                },\n                version: 1\n            });\n            printSessionForSimiluationPrep('Login_ApproveOperation', args.operation.id);\n        },\n        async closeOperation(context): Promise<void> {\n            const accountId = randomPassword();\n            const sessionId = context.operation.id;\n            const sessionRecordPromise = getSessionRecord(sessionId);\n            if (context.operation.type === EOperationType.Registration) {\n                const relativePath = `save/${sessionId}/${accountId}`;\n                await showUi(context, sessionId, relativePath, sessionRecordPromise);\n                const sessionRecord = await sessionRecordPromise;\n                const newAccountId = await db.accounts.add({\n                    id: accountId,\n                    date: new Date().toISOString(),\n                    registrationUri: context.document.uri,\n                    fields: sessionRecord.fields || [],\n                    webAppActor: context.channel.webAppActor,\n                    userAttributes: sessionRecord.userAttributes || {},\n                    metadata: sessionRecord.metadata\n                });\n                const change: Pick<Session, 'createdAccountId' | 'requests' | 'version' | 'closed'> = {\n                    createdAccountId: newAccountId as string, // BRTTODO: Perhaps change ids from strings to IndexableType for all references.\n                    requests: sessionRecord.requests.concat(context.request),\n                    version: sessionRecord.version + 1,\n                    closed: true\n                };\n                await db.sessions.update(sessionId, change);\n            } else {\n                const relativePath = `auth/${sessionId}/finished`;\n                await showUi(context, sessionId, relativePath, sessionRecordPromise);\n\n                const sessionRecord = await sessionRecordPromise;\n                const change: Pick<Session, 'requests' | 'version' | 'closed'> = {\n                    requests: sessionRecord.requests.concat(context.request),\n                    version: sessionRecord.version + 1,\n                    closed: true\n                };\n                await db.sessions.update(sessionId, change);\n            }\n            printSessionForSimiluationPrep(\"Login_CloseOperation\", sessionId);\n        },\n        async getRecordMetadata(context): Promise<void> {\n            const sessionId = context.operation.id;\n            const sessionRecord = await getSessionRecord(sessionId);\n            if (context.operation.type === EOperationType.Registration) {\n                context.response.resolve(sessionRecord.metadata);\n                return;\n            }\n            const account = await db.accounts.get(sessionRecord.selectedAccountId!);\n            if (! account) {\n                throw new Error('unable to get account record, the account id does not exist.');\n            }\n            context.response.resolve(account.metadata);\n        },\n        async updateMetadata(context, args): Promise<void> {\n            const sessionId = context.operation.id;\n            const sessionRecord = await getSessionRecord(sessionId);\n            const change: Pick<Session, 'metadata' | 'version'> = {\n                metadata: {\n                    ...sessionRecord.metadata,\n                    ...args.metadata\n                },\n                version: sessionRecord.version + 1\n            };\n            await db.sessions.update(sessionRecord, change);\n            context.response.resolve();\n        }\n    },\n    accountCreation: {\n        async approveTransitionToAuthOp(context, args): Promise<void> {\n            const currSessionId = context.operation.id;\n            const nextSessionId = args.newAuthOp.id;\n            const currSessionRecordPromise = getSessionRecord(currSessionId);\n            const relativePath = `transition-to-auth-op/${currSessionId}/${nextSessionId}`;\n            await showUi(context, currSessionId, relativePath, currSessionRecordPromise);\n\n            const currSession = await currSessionRecordPromise;\n            if (! currSession.createdAccountId) {\n                throw new Error(\"Expecting createdAccountId to be set when transitioning!\");\n            }\n            const account = await db.accounts.get(currSession.createdAccountId);\n            if (! account) {\n                throw new Error(\"Expecting account to be created before transitioning.\");\n            }\n            await db.sessions.add({\n                id: nextSessionId,\n                channel: context.channel,\n                operation: args.newAuthOp,\n                requests: [context.request],\n                transitionedFromSessionId: currSessionId,\n                context: plainContext(context),\n                tabId: currSession.tabId, // window tab id. not the content page tab id.\n                selectedAccountId: currSession.createdAccountId,\n                metadata: account.metadata,\n                version: 1,\n            });\n            printSessionForSimiluationPrep('AccountCreation_ApproveTransitionToAuthOp', nextSessionId);\n        },\n        async getUserAttributes(context): Promise<void> {\n            const sessionId = context.operation.id;\n            const sessionRecordPromise = getSessionRecord(sessionId);\n            {/* BRTTODO: 23/1/2024 Remove afterVersion -- this seems to be problematic. We should refactor how we process requests to use request id instead */}\n            const relativePath = `get-user-attributes/${sessionId}/1`;\n            await showUi(context, sessionId, relativePath, sessionRecordPromise);\n            const sessionRecord = await sessionRecordPromise;\n            const requiredUserAttributes: Partial<Record<keyof typeof userAttributesLabels, boolean>> = {};\n            (Object.keys(userAttributesLabels) as Array<keyof typeof userAttributesLabels>)\n                .map(key => {\n                    requiredUserAttributes[key] = false;\n                });\n            context.operation.requestedUserAttributes.forEach(({ id, required }) => {\n                requiredUserAttributes[id] = required;\n            });\n            const change: Pick<Session, 'requests' | 'requiredUserAttributes' | 'version'> = {\n                requiredUserAttributes: requiredUserAttributes as Record<keyof typeof userAttributesLabels, boolean>,\n                requests: sessionRecord.requests.concat(context.request),\n                version: 2\n            };\n            await db.sessions.update(sessionId, change);\n            printSessionForSimiluationPrep('AccountCreation_GetUserAttributes', sessionId);\n        },\n        updateUserAttributes(context, args): void {\n            throw new Error(\"Function not implemented.\");\n        },\n        async addField(context, args): Promise<void> {\n            const sessionId = context.operation.id;\n            const sessionRecordPromise = getSessionRecord(sessionId);\n            if (args.field.value === null) {\n                const relativePath = `create-field/${sessionId}/${args.field.id}`;\n                await showUi(context, sessionId, relativePath, sessionRecordPromise);\n                const sessionRecord = await sessionRecordPromise;\n                if (\n                    sessionRecord.createFieldOptions &&\n                    sessionRecord.createFieldOptions.find(o => o.id === args.field.id)\n                ) {\n                    browser.berytus.rejectRequest(context.request.id, ERejectionCode.GeneralError);\n                    return;\n                }\n                const change: Pick<Session, 'requests' | 'createFieldOptions' | 'version'> = {\n                    requests: sessionRecord.requests.concat(context.request),\n                    createFieldOptions: (sessionRecord.createFieldOptions || []).concat({\n                        id: args.field.id,\n                        type: args.field.type,\n                        options: args.field.options\n                    }),\n                    version: sessionRecord.version + 1\n                };\n                await db.sessions.update(sessionId, change);\n                printSessionForSimiluationPrep('AccountCreation_AddField', sessionId);\n                return;\n            }\n            const relativePath = `put-field/${sessionId}/${args.field.id}`;\n            await showUi(context, sessionId, relativePath, sessionRecordPromise);\n            const sessionRecord = await sessionRecordPromise;\n            if (\n                sessionRecord.putFields?.find(o => o.id === args.field.id)\n            ) {\n                browser.berytus.rejectRequest(context.request.id, ERejectionCode.GeneralError);\n                return;\n            }\n            if (args.field.type === \"Key\" || args.field.type === \"SecurePassword\") {\n                console.warn(\"PutField of type Key or SecurePassword are not allowed.\");\n                // TODO(berytus): Implement a logical validator in ValidatedRequestHandler\n                browser.berytus.rejectRequest(context.request.id, ERejectionCode.GeneralError);\n                return;\n            }\n            const change: Pick<Session, 'requests' | 'putFields' | 'version'> = {\n                requests: sessionRecord.requests.concat(context.request),\n                putFields: (sessionRecord.putFields || []).concat({\n                    id: args.field.id,\n                    type: args.field.type,\n                    options: args.field.options,\n                    value: args.field.type === \"SharedKey\"\n                        ? stringifyArrayBufferOrEncryptedPacket(args.field.value.privateKey)\n                        : typeof args.field.value === \"string\"\n                            ? args.field.value\n                            : stringifyEncryptedPacket(args.field.value)\n                }),\n                version: sessionRecord.version + 1\n            };\n            await db.sessions.update(sessionId, change);\n            printSessionForSimiluationPrep('AccountCreation_AddField:Put', sessionId);\n        },\n        async rejectFieldValue(context, args): Promise<void> {\n            const sessionId = context.operation.id;\n            const sessionRecordPromise = getSessionRecord(sessionId);\n\n            const relativePath = `create-field/${sessionId}/${args.fieldId}/rejected`;\n            await showUi(context, sessionId, relativePath, sessionRecordPromise);\n            const sessionRecord = await sessionRecordPromise;\n            const field = sessionRecord.fields?.find(f => f.id === args.fieldId);\n            const rejectedFieldValueIndex = sessionRecord.rejectedFieldValues?.findIndex(f => f.fieldId === args.fieldId);\n            if (\n                !sessionRecord.createFieldOptions?.find(o => o.id === args.fieldId) ||\n                !field\n            ) {\n                browser.berytus.rejectRequest(context.request.id, ERejectionCode.GeneralError);\n                return;\n            }\n            if (\n                typeof args.optionalNewValue === \"object\" && (\n                    \"publicKey\" in args.optionalNewValue ||\n                    \"salt\" in args.optionalNewValue\n                )\n            ) {\n                console.warn(\"RejectField of type Key or SecurePassword are not allowed.\");\n                // TODO(berytus): Implement a logical validator in ValidatedRequestHandler\n                browser.berytus.rejectRequest(context.request.id, ERejectionCode.GeneralError);\n                return;\n            }\n            if (\n                typeof args.optionalNewValue === \"object\" &&\n                args.optionalNewValue !== null &&\n                \"ciphertext\" in args.optionalNewValue) {\n                console.warn(\"TODO(berytus): handle encrypted values\");\n                browser.berytus.rejectRequest(context.request.id, ERejectionCode.GeneralError);\n                return;\n            }\n            let change: Pick<Session, 'requests' | 'rejectedFieldValues' | 'version'>;\n            let sameValue = false;\n            let value = undefined;\n            do {\n                if (! args.optionalNewValue) {\n                    break;\n                }\n                if (typeof args.optionalNewValue === \"string\") {\n                    sameValue = args.optionalNewValue === field.value;\n                    value = args.optionalNewValue;\n                    break;\n                }\n                if (args.optionalNewValue.privateKey instanceof ArrayBuffer) {\n                    value =  ab2base64(args.optionalNewValue.privateKey);\n                    sameValue = value === field.value;\n                    break;\n                }\n                console.warn(\"TODO(berytus): handle encrypted values\");\n            } while (false);\n            if (sameValue) {\n                // BRTTODO: A web app can reject a field value while dictating its new\n                // value the same as the previous one (the one being rejected). This\n                // should not happen, but since the AuthRealm API does not\n                // store field values, it cannot validate whether the optionalNewValue\n                // is different than the rejected one (or previously rejected).\n                // So for now, we throw an error here.\n                console.error('BRTTODO: WebApp rejected field value with an new value that equals the rejected one. Genuis.');\n                throw new Error('Unable to rejectRegistrationField. WebApp rejected the field value with an invalid new value.');\n            }\n            if (rejectedFieldValueIndex === undefined || rejectedFieldValueIndex === -1) {\n                change = {\n                    requests: sessionRecord.requests.concat(context.request),\n                    rejectedFieldValues: (sessionRecord.rejectedFieldValues || []).concat({\n                        fieldId: args.fieldId,\n                        code: args.reason.code,\n                        webAppDictatedValue: value,\n                        previousValues: [field.value]\n                    }),\n                    version: sessionRecord.version + 1\n                };\n            } else {\n                if (sessionRecord.rejectedFieldValues![rejectedFieldValueIndex].webAppDictatedValue) {\n                    throw new Error('This field has been rejected and overriden previously!');\n                }\n                sessionRecord.rejectedFieldValues![rejectedFieldValueIndex].webAppDictatedValue =\n                    value;\n                sessionRecord.rejectedFieldValues![rejectedFieldValueIndex].previousValues.push(\n                    field.value\n                );\n                change = {\n                    requests: sessionRecord.requests.concat(context.request),\n                    rejectedFieldValues: sessionRecord.rejectedFieldValues!,\n                    version: sessionRecord.version + 1\n                };\n            }\n            await db.sessions.update(sessionId, change);\n            printSessionForSimiluationPrep('AccountCreation_RejectFieldValue', sessionId);\n        }\n    },\n    accountAuthentication: {\n        async approveChallengeRequest(context, args): Promise<void> {\n            const sessionId = context.operation.id;\n            const sessionRecordPromise = getSessionRecord(sessionId);\n            const challengeId = args.challenge.id;\n            const relativePath = `auth/${sessionId}/challenge/${challengeId}/approve`;\n\n            await showUi(context, sessionId, relativePath, sessionRecordPromise);\n            const sessionRecord = await sessionRecordPromise;\n            const change: Pick<Session, 'challenges' | 'requests' | 'version'> = {\n                challenges: {\n                    ...sessionRecord.challenges,\n                    [challengeId]: {\n                        ...args.challenge,\n                        messages: {}\n                    }\n                },\n                requests: sessionRecord.requests.concat(context.request),\n                version: sessionRecord.version + 1\n            };\n\n            await db.sessions.update(sessionRecord, change);\n            printSessionForSimiluationPrep('AccountAuthentication_ApproveChallengeRequest', sessionId);\n        },\n        async abortChallenge(context, args): Promise<void> {\n            const sessionId = context.operation.id;\n            const sessionRecordPromise = getSessionRecord(sessionId);\n            const challengeId = args.challenge.id;\n            const relativePath = `auth/${sessionId}/challenge/${challengeId}/aborted`;\n\n            await showUi(context, sessionId, relativePath, sessionRecordPromise);\n            const sessionRecord = await sessionRecordPromise;\n            await db.sessions.update(sessionRecord, {\n                requests: sessionRecord.requests.concat(context.request),\n                [`challenges.${challengeId}.closed`]: true,\n                [`challenges.${challengeId}.abortionReasonCode`]: args.reason\n            });\n            printSessionForSimiluationPrep('AccountAuthentication_AbortChallenge', sessionId);\n        },\n        async closeChallenge(context, args): Promise<void> {\n            const sessionId = context.operation.id;\n            const sessionRecordPromise = getSessionRecord(sessionId);\n            const challengeId = args.challenge.id;\n            const relativePath = `auth/${sessionId}/challenge/${challengeId}/sealed`;\n\n            await showUi(context, sessionId, relativePath, sessionRecordPromise);\n            const sessionRecord = await sessionRecordPromise;\n            await db.sessions.update(sessionRecord, {\n                requests: sessionRecord.requests.concat(context.request),\n                [`challenges.${challengeId}.closed`]: true\n            });\n            printSessionForSimiluationPrep('AccountAuthentication_CloseChallenge', sessionId);\n        },\n        async respondToChallengeMessage(context, args): Promise<void> {\n            const sessionId = context.operation.id;\n            const sessionRecordPromise = getSessionRecord(sessionId);\n            const challengeId = args.challenge.id;\n            const messageId = args.name;\n            const relativePath = `auth/${sessionId}/challenge/${challengeId}/message/${messageId}`;\n\n            await showUi(context, sessionId, relativePath, sessionRecordPromise);\n            const sessionRecord = await sessionRecordPromise;\n            let payload;\n            if (typeof args.payload === \"string\") {\n                payload = args.payload;\n            } else if (args.payload instanceof ArrayBuffer) {\n                payload = ab2base64(args.payload);\n            } else if (ArrayBuffer.isView(args.payload)) {\n                console.warn(\"TODO(berytus): Remove ArrayBufferView support\");\n                context.response.reject(ERejectionCode.GeneralError);\n                return;\n            } else if (Array.isArray(args.payload)) {\n                payload = args.payload;\n            } else {\n                console.warn(\"TODO(berytus): Support Encrypted Packet\");\n                context.response.reject(ERejectionCode.GeneralError);\n                return;\n            }\n            await db.sessions.update(sessionRecord, {\n                [`challenges.${challengeId}.messages.${messageId}`]: {\n                    name: messageId,\n                    payload\n                },\n                requests: sessionRecord.requests.concat(context.request),\n                version: sessionRecord.version + 1\n            });\n            printSessionForSimiluationPrep('AccountAuthentication_RespondToChallengeMessage', sessionId);\n        }\n    }\n});","import{ generate } from \"do_username\";\nimport { EBerytusFieldType } from \"@berytus/enums\";\n\nexport const randomPassword = () => {\n    const bytes = new Uint8Array(16);\n    window.crypto.getRandomValues(bytes);\n    let blocks: Array<string> = [];\n    const lang = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9']\n    for (let i = 0; i < bytes.length; i++) {\n        const num = bytes[i];\n        blocks[i % 4] = (blocks[i % 4] || \"\") +\n            lang[num % lang.length];\n    }\n    return blocks.join('-');\n}\n\nexport const randomUsername = () => {\n    const suffix = randomPassword().substring(0, 4);\n    return generate(8) + suffix;\n}\n\nexport type BgColor = `bg-${string}`;\n\n\nexport async function randomFieldValue(fieldType: typeof EBerytusFieldType[keyof typeof EBerytusFieldType]): Promise<string | ArrayBuffer> {\n    switch (fieldType) {\n        case EBerytusFieldType.Identity:\n            return randomUsername();\n        case EBerytusFieldType.Password:\n        case EBerytusFieldType.SecurePassword:\n            return randomPassword();\n        case EBerytusFieldType.Key:\n            const genKey = await crypto.subtle.generateKey(\n                {\n                    name: \"RSA-OAEP\",\n                    modulusLength: 4096,\n                    publicExponent: new Uint8Array([1, 0, 1]),\n                    hash: \"SHA-256\",\n                },\n                true,\n                [\"encrypt\", \"decrypt\"]\n            );\n            const privKeyBuf = await window.crypto.subtle.exportKey(\"pkcs8\", genKey.privateKey);\n            return privKeyBuf;\n        default:\n            throw new Error('error: generateStr received an invalid fieldType ' + EBerytusFieldType[fieldType]);\n    }\n}\n\nexport const notEmpty = (str: string | undefined): boolean => {\n    if (str === undefined) {\n        return false;\n    }\n    return str.length > 0;\n}\n\nexport const scrollTopSmooth = () => {\n    window.scrollTo({\n        top: 0,\n        left: 0,\n        behavior: 'smooth'\n    });\n};\n\nexport const concatErrorMessages = (...args: Array<Error | undefined>): string => {\n    let res: Array<string> = [];\n    for (let i = 0; i < args.length; i++) {\n        const err = args[i];\n        if (! err) {\n            continue;\n        }\n        res.push(err.message);\n    }\n    return res.join(' && ');\n}\n\nexport function atLeastOneErrorSet(errors?: Array<Error | undefined>): boolean {\n    if (! errors) {\n        return false;\n    }\n    for (let i = 0; i < errors.length; i++) {\n        if (errors[i]) {\n            return true;\n        }\n    }\n    return false;\n}","const SEA_CREATURES = module.exports.SEA_CREATURES = Object.freeze([\n    'walrus', 'seal', 'fish', 'shark', 'clam', 'coral', 'whale', 'crab',\n    'lobster', 'starfish', 'eel', 'dolphin', 'squid', 'jellyfish', 'ray',\n    'shrimp', 'mantaRay', 'angler', 'snorkler', 'scubaDiver', 'urchin',\n    'anemone', 'morel', 'axolotl',\n]);\n\nconst SEA_OBJECTS = module.exports.SEA_OBJECTS = Object.freeze([\n    'boat', 'ship', 'submarine', 'yacht', 'dinghy', 'raft', 'kelp',\n    'seaweed', 'anchor',\n]);\n\nconst ADJECTIVE_DESCRIPTORS = module.exports.ADJECTIVE_DESCRIPTORS = Object.freeze([\n    'cute', 'adorable', 'lovable', 'happy', 'sandy', 'bubbly', 'friendly',\n    'floating', 'drifting',\n]);\n\nconst SIZE_DESCRIPTORS = module.exports.SIZE_DESCRIPTORS = Object.freeze([\n    'large', 'big', 'small', 'giant', 'massive', 'tiny', 'little',\n]);\n\nmodule.exports.CREATURE_DESCRIPTORS = Object.freeze([\n    'swimming', 'sleeping', 'eating', 'hiding',\n]);\n\nmodule.exports.SEA_LIST = Object.freeze(\n    SEA_OBJECTS.concat(SEA_CREATURES),\n);\n\nmodule.exports.DESCRIPTORS = Object.freeze(\n    ADJECTIVE_DESCRIPTORS.concat(SIZE_DESCRIPTORS),\n);\n\nmodule.exports.COLORS = Object.freeze([\n    'blue', 'blueGreen', 'darkCyan', 'electricBlue', 'greenBlue',\n    'lightCyan', 'lightSeaGreen', 'seaGreen', 'turquoise', 'aqua',\n    'aquamarine', 'teal', 'cyan', 'gray', 'darkBlue', 'cerulean', 'azure',\n    'lapis', 'navy',\n]);\n","const {\n    SEA_LIST,\n    SEA_CREATURES,\n    DESCRIPTORS,\n    COLORS,\n    CREATURE_DESCRIPTORS,\n    ADJECTIVE_DESCRIPTORS,\n    SEA_OBJECTS,\n    SIZE_DESCRIPTORS,\n} = require('./constants');\n\nconst { randomNoun, randomDescriptor, randomColor, format, combineUsername } = require('./private_functions');\n\nconst generate = (maxSize = 30) => {\n    if (maxSize <= 0 || typeof maxSize !== 'number') {\n        throw new Error('The maxSize argument must be an integer number greater than zero.');\n    }\n\n    let noun = randomNoun();\n    let descriptor = randomDescriptor(noun);\n    let color = randomColor();\n\n    noun = format(noun);\n    descriptor = format(descriptor);\n    color = format(color);\n\n    return combineUsername(maxSize, descriptor, color, noun);\n};\n\nmodule.exports = {\n    SEA_LIST,\n    SEA_CREATURES,\n    DESCRIPTORS,\n    COLORS,\n    CREATURE_DESCRIPTORS,\n    ADJECTIVE_DESCRIPTORS,\n    SEA_OBJECTS,\n    SIZE_DESCRIPTORS,\n    generate,\n};\n","const { SEA_LIST, SEA_CREATURES, DESCRIPTORS, COLORS, CREATURE_DESCRIPTORS } = require('./constants');\n\nconst random = (items) => items[Math.random() * items.length | 0];\n\nmodule.exports.randomNoun = () => random(SEA_LIST);\n\nmodule.exports.randomDescriptor = (noun) => {\n    if (!SEA_CREATURES.includes(noun)) return random(DESCRIPTORS);\n\n    return random(DESCRIPTORS.concat(CREATURE_DESCRIPTORS));\n};\n\nmodule.exports.format = (string) => string[0].toUpperCase() + string.slice(1);\n\nmodule.exports.randomColor = () => random(COLORS);\n\nmodule.exports.combineUsername = (maxSize, descriptor, color, noun) => {\n    if ((descriptor + color + noun).length <= maxSize)\n        return descriptor + color + noun;\n    else if ((descriptor + noun).length <= maxSize)\n        return descriptor + noun;\n    else if ((color + noun).length <= maxSize)\n        return color + noun;\n    else\n        return noun.slice(0, maxSize);\n};\n"],"names":["PRIMARY_IDENTITY_ID","PRIMARY_SETTINGS_ID","SecretDexie","Dexie","constructor","super","accounts","sessions","identity","picture","channel","webApp","pendingRequests","settings","this","version","stores","webAppKey","on","async","db","dexieDb","count","add","id","seamless","signup","login","get","Error","change","update","_objectSpread","f","data","btoa","String","fromCharCode","apply","Uint8Array","arrayBuffer","put","filename","name","type","findCorrespondingAccounts","givenActor","category","filter","_ref","webAppActor","metadata","actorB","actorA","ed25519Key","originalUri","hostname","undefined","matchActors","pictureToDataUrl","concat","PAGECONTEXT_POPUP","indexUrl","_browser","browser","_browser$runtime","runtime","getURL","url","relativePath","appPageContext","startsWith","getSessionRecord","record","sessionId","EOperationType","ERejectionCode","EMetadataStatus","ab2base64","buffer","ab2str","userAttributesLabels","stringifyEncryptedPacket","value","parameters","Object","keys","forEach","key","prop","ArrayBuffer","JSON","stringify","ciphertext","openPageActionPopupIfNecessary","absolutePath","requestId","tabId","pageAction","show","prom0","associateTabIdWithRequest","prom1","tabIdWherePageActionIs","path","relative","arguments","length","setPopup","popup","setPageActionUrlInTab","prom2","openPopup","tabDictKey","storage","session","set","onMessage","addListener","request","sender","sendResponse","console","log","hide","getAssociatedTabId","Promise","resolve","e","warn","error","remove","deleteTabIdAssociation","send","berytus","resolveRequest","rejectRequest","debug","then","plainContext","context","response","printSessionForSimiluationPrep","phase","showUi","sessionRecordPromise","document","registerRequestHandler","manager","args","publicKey","Math","floor","random","webAppEd25519Key","scmEd25519Key","privateKey","accountConstraints","schemaVersion","salt","info","window","crypto","getRandomValues","scmX25519Key","subtle","generateKey","params","aesKeyLength","hkdfHash","hkdfSalt","hkdfInfo","webAppX25519Key","paramsDraft","exportKey","webAppSignature","webAppPacketSignature","closeChannel","_context$channel$cons","_context$channel$cons2","operation","requests","constraints","account","status","Pending","changePassUrl","accountId","randomPassword","bytes","blocks","lang","i","num","join","Registration","sessionRecord","createdAccountId","date","Date","toISOString","registrationUri","uri","fields","userAttributes","closed","selectedAccountId","accountCreation","currSessionId","nextSessionId","newAuthOp","currSessionRecordPromise","currSession","transitionedFromSessionId","requiredUserAttributes","map","requestedUserAttributes","required","updateUserAttributes","_sessionRecord$putFie","field","createFieldOptions","find","o","GeneralError","options","putFields","_sessionRecord$fields","_sessionRecord$reject","_sessionRecord$create","fieldId","rejectedFieldValueIndex","rejectedFieldValues","findIndex","optionalNewValue","sameValue","code","reason","webAppDictatedValue","previousValues","push","accountAuthentication","challengeId","challenge","challenges","messages","messageId","payload","isView","reject","Array","isArray","SEA_CREATURES","module","exports","freeze","SEA_OBJECTS","ADJECTIVE_DESCRIPTORS","SIZE_DESCRIPTORS","CREATURE_DESCRIPTORS","SEA_LIST","DESCRIPTORS","COLORS","require","randomNoun","randomDescriptor","randomColor","format","combineUsername","generate","maxSize","noun","descriptor","color","items","includes","string","toUpperCase","slice"],"sourceRoot":""}