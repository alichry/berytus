{"version":3,"file":"static/js/main.js","mappings":"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","sources":["../node_modules/do_username/lib/private_functions.js","db/Identity.ts","db/db.ts","pagecontext.ts","workers/paths.ts","workers/session-utils.ts","../../../../toolkit/components/berytus/src/types.ts","key-utils.ts","ui/utils/userAttributesLabels.ts","workers/field-utils.ts","workers/pageAction-popup-fix.ts","workers/pageAction-utils.ts","workers/main.ts","db/Channel.ts","utils.ts","../node_modules/do_username/lib/do_username.js","../node_modules/do_username/lib/constants.js"],"sourcesContent":["const { SEA_LIST, SEA_CREATURES, DESCRIPTORS, COLORS, CREATURE_DESCRIPTORS } = require('./constants');\n\nconst random = (items) => items[Math.random() * items.length | 0];\n\nmodule.exports.randomNoun = () => random(SEA_LIST);\n\nmodule.exports.randomDescriptor = (noun) => {\n    if (!SEA_CREATURES.includes(noun)) return random(DESCRIPTORS);\n\n    return random(DESCRIPTORS.concat(CREATURE_DESCRIPTORS));\n};\n\nmodule.exports.format = (string) => string[0].toUpperCase() + string.slice(1);\n\nmodule.exports.randomColor = () => random(COLORS);\n\nmodule.exports.combineUsername = (maxSize, descriptor, color, noun) => {\n    if ((descriptor + color + noun).length <= maxSize)\n        return descriptor + color + noun;\n    else if ((descriptor + noun).length <= maxSize)\n        return descriptor + noun;\n    else if ((color + noun).length <= maxSize)\n        return color + noun;\n    else\n        return noun.slice(0, maxSize);\n};\n","import type { UserAttributeKey } from \"@berytus/types\";\nimport { UserAttribute } from \"./db\";\n\n// Not all users have a website, a profile page, or\n// ... a picture.\nconst optionalKeys = [\"profile\", \"picture\", \"website\"] as const;\nexport function isUserAttributeKeyOptional(key: string): boolean {\n    return optionalKeys.indexOf(\n        key as OptionalUserAttributeKey\n    ) !== -1;\n}\ntype OptionalUserAttributeKey = typeof optionalKeys[number];\n\nexport type UserAttributes = Record<\n    Exclude<UserAttributeKey, OptionalUserAttributeKey>,\n    UserAttribute\n> & Partial<Record<OptionalUserAttributeKey, UserAttribute>>;\n\nexport interface Identity {\n    id: string;\n    userAttributes?: UserAttributes;\n    emailAddress?: string;\n    mobileNumber?: string;\n}\n\nexport const PRIMARY_IDENTITY_ID = \"primary\";","import Dexie, { Table } from 'dexie';\nimport { SingleChange } from './ts-utils';\nimport { Identity, PRIMARY_IDENTITY_ID } from './Identity';\nimport { Picture } from './Picture';\nimport { Channel } from './Channel';\nimport { WebApp } from './WebApp';\nimport type { Request, FieldInfo, FieldValueRejectionReason, RecordMetadata, BerytusSendMessageUnion, PreliminaryRequestContext, BerytusChallengeInfoUnion, UserAttributeKey, WebAppActor, ChannelMetadata, LoginOperationMetadata, UriParams, RequestContext, RequestContextWithOperation, RequestContextWithLoginOperation } from '@berytus/types';\nimport { EBerytusChallengeType } from \"@berytus/enums\";\nimport { BerytusEncryptedPacket } from '@berytus/types-extd';\nimport { SigningKey } from './SigningKey';\n\nexport interface Field extends FieldInfo {\n  value: string;\n}\n\nexport interface FieldValueRejection extends FieldValueRejectionReason {\n  fieldId: string;\n  webAppDictatedValue?: Field['value'];\n  previousValues: Array<Field['value']>;\n}\n\nexport interface UserAttribute {\n  id: UserAttributeKey;\n  mimeType?: string;\n  // TODO(berytus): REmove this once we remove ArrayBufferViews.\n  value: string | ArrayBuffer | ArrayBufferView | BerytusEncryptedPacket;\n}\n\nexport interface PutField extends FieldInfo {\n  value: string;\n}\n\nexport interface ChallengeMessage extends Omit<BerytusSendMessageUnion, 'challenge' | 'payload'> {\n  payload: string | string[];\n}\n\nexport type Challenge = BerytusChallengeInfoUnion & {\n  messages: Record<string, ChallengeMessage>;\n  closed?: boolean;\n  abortionReasonCode?: string;\n};\n\nexport type SrpChallenge = Challenge & {\n  type: EBerytusChallengeType.SecureRemotePassword;\n  srpState: {\n    fields: { username: string; password: string };\n    serverPublicKeyHexB?: string;\n    clientPrivateKeyHexa?: string;\n    clientPublicKeyHexA?: string; /* Not really needed in any computation, but good for debugging */\n    salt?: string;\n    clientProof?: string;\n    serverProofValid?: boolean;\n  }\n}\n\nexport type DsChallenge = Challenge & {\n  type: EBerytusChallengeType.DigitalSignature;\n  dsState: {\n    // PEM\n    privateKey: string;\n    nonce?: string;\n    signedMessage?: string;\n  }\n}\n\nexport type RRequiredUserAttributes = Record<UserAttributeKey, boolean>;\nexport type RUserAttributes = Record<UserAttributeKey, UserAttribute>;\n\nexport interface Session {\n  id: string;\n  /**\n   * This is the ExtensionRequestContext. Currently, it holds the active\n   * request and the tabId where the Authentication or Registration session is.\n   */\n  context: PreliminaryRequestContext | RequestContext | RequestContextWithOperation | RequestContextWithLoginOperation;\n  /**\n   * Only set in the MODE_EXTERNAL_WINDOW mode. If set, this is\n   * the tabId of the created window. See session-utils.ts->openWindowOrRedirectTab\n   * This is the tab id that corresponds to the Password Manager (us) -'s\n   * created window for request processing (approve session, select user\n   * attributes, etc). This is not the tab id where the Authentication or\n   * Registration session is.\n   */\n  tabId?: number;\n  channel: ChannelMetadata;\n  operation: LoginOperationMetadata;\n  //sessionInfo: OperationMetadata;\n  requests: Array<Request>;\n  requiredUserAttributes?: RRequiredUserAttributes;\n  userAttributes?: Partial<RUserAttributes>;\n  createFieldOptions?: Array<FieldInfo>;\n  putFields?: Array<PutField>;\n  fields?: Array<Field>;\n  rejectedFieldValues?: Array<FieldValueRejection>;\n  metadata: RecordMetadata;\n  createdAccountId?: string;\n  transitionedFromSessionId?: string;\n  /**\n   * Auth session attributes.\n   * TODO: Separate the registration session attributes\n   * from the auth ones\n   */\n  selectedAccountId?: string;\n  challenges?: Record<string, Challenge | SrpChallenge | DsChallenge>;\n  /**\n   * Numeric version of the record. This is used by React Components that expects\n   * a newer version. This is helpful when the background script opens a popup,\n   * but without waiting until the record has been updated. The React Component\n   * expects a record after a specific 'version' where this attribute indicates.\n   */\n  version: number;\n  saved?: boolean;\n  closed?: boolean;\n}\n\nexport interface Account {\n    id: string;\n    registrationUri: UriParams;\n    webAppActor: WebAppActor;\n    userAttributes: Partial<Record<UserAttributeKey, UserAttribute>>;\n    fields: Array<Field>;\n    date: string;\n    metadata: RecordMetadata;\n}\n\nexport interface Settings {\n  seamless: { signup: boolean; login: boolean };\n}\n\nexport const PRIMARY_SETTINGS_ID = \"primary\";\n\nexport interface PendingRequest {\n  id: string;\n  url: string;\n  tabId: number;\n}\n\nexport class SecretDexie extends Dexie {\n  // 'friends' is added by dexie when declaring the stores()\n  // We just tell the typing system this is the case\n  accounts!: Table<Account>;\n  sessions!: Table<Session>;\n  identity!: Table<Identity>;\n  picture!: Table<Picture>;\n  channel!: Table<Channel>;\n  signingKeys!: Table<SigningKey>;\n  webApp!: Table<WebApp>;\n  pendingRequests!: Table<PendingRequest>;\n  protected settings!: Table<Settings & { id: string }>;\n\n  constructor() {\n    super('secret*');\n    this.version(1).stores({\n      accounts: 'id',\n      sessions: 'id',\n      identity: 'id',\n      settings: 'id',\n      picture: 'filename',\n      channel: 'id',\n      webAppKey: '++id, ed25519Key',\n      pendingRequests: 'id',\n      signingKeys: 'public, private'\n    });\n    this.on('ready', async (dexieDb: Dexie) => {\n      const db = dexieDb as SecretDexie;\n      if ((await db.settings.count()) === 0) {\n        db.settings.add({\n          id: PRIMARY_SETTINGS_ID,\n          seamless: { signup: false, login: false }\n        });\n      }\n      if ((await db.identity.count()) === 0) {\n        db.identity.add({ id: PRIMARY_IDENTITY_ID });\n      }\n    });\n  }\n\n  async getSettings() {\n    const settings = await this.settings.get(PRIMARY_SETTINGS_ID);\n    if (! settings) {\n      throw new Error(\"What?\");\n    }\n    return settings;\n  }\n\n  async updateSettings(change: SingleChange<Settings>) {\n    return this.settings.update(PRIMARY_SETTINGS_ID, {\n      ...change\n    });\n  }\n\n  async getIdentity(): Promise<Identity> {\n    const identity = await this.identity.get(PRIMARY_IDENTITY_ID);\n    if (! identity) {\n      throw new Error('Expecting identity to be set!');\n    }\n    return identity;\n  }\n\n  async savePicture(f: File) {\n    const data = btoa(String.fromCharCode.apply(null, new Uint8Array(await f.arrayBuffer()) as any));\n    const picture = await this.picture.put({\n      filename: f.name,\n      type: f.type,\n      data\n    });\n    return picture;\n  }\n\n  findCorrespondingAccounts(\n    givenActor: WebAppActor,\n    category?: string,\n    version?: number\n  ) {\n    const matchActors = (actorA: WebAppActor, actorB: WebAppActor): boolean => {\n      if (\"ed25519Key\" in actorA) {\n        if (!(\"ed25519Key\" in actorB)) {\n          return false;\n        }\n        return actorA.ed25519Key === actorB.ed25519Key;\n      }\n      if (\"ed25519Key\" in actorB) {\n        return false;\n      }\n      return actorB.originalUri.hostname === actorA.originalUri.hostname;\n    }\n    return this.accounts.filter(\n      ({ webAppActor, metadata }) => {\n        if (! matchActors(givenActor, webAppActor)) {\n          return false;\n        }\n        if (\n          category !== undefined &&\n          category !== metadata.category\n        ) {\n          return false;\n        }\n        if (\n          version !== undefined &&\n          version !== metadata.version\n        ) {\n          return false;\n        }\n        return true;\n      }\n      );\n  }\n\n  pictureToDataUrl(picture: Picture) {\n    return `data:${picture.type};base64,${picture.data}`;\n  }\n}\n\nexport const db = new SecretDexie();\n\n// Just needed to distriibute T when it is a union.\ntype KeyOf<T> = T extends any ? keyof T : never;\nconst Algorithms: Record<number, string> = {\n  [-42]: \"RSAES-OAEP w/ SHA-256\"\n};\n\nexport const fieldOptionValueToString = (optionName: KeyOf<Field['options']>, value: Field['options'][keyof Field['options']]): string => {\n  if (value === undefined) {\n    return \"\";\n  }\n  if (optionName === 'alg') {\n    return Algorithms[Number(value)] || `COSE:${value}`;\n  }\n  return String(value);\n}\n\nexport const isSrpChallenge = (challenge: Challenge): challenge is SrpChallenge => {\n  return \"srpState\" in challenge;\n}\nexport const isDsChallenge = (challenge: Challenge): challenge is DsChallenge => {\n  return \"dsState\" in challenge;\n}\n\n//import('./dummy-data');","export const PAGECONTEXT_WINDOW = \"window\";\nexport const PAGECONTEXT_POPUP = \"popup\";\n\nexport const allowedPageContexts = [\n    PAGECONTEXT_WINDOW,\n    PAGECONTEXT_POPUP\n] as const;\n\nexport type AppPageContext = typeof PAGECONTEXT_WINDOW | typeof PAGECONTEXT_POPUP;\n\nexport const isPopup = (pageContext: string) => {\n    return pageContext === PAGECONTEXT_POPUP;\n}","import { AppPageContext } from \"@root/pagecontext\";\n\nexport const indexUrl =\n    browser?.runtime?.getURL\n        ? browser.runtime.getURL('build/index.html') + \"#\"\n        : 'http://localhost:3000';\n\nexport const paths = { loading: `loading` };\n\nexport const url = (relativePath: string, appPageContext: AppPageContext) => {\n    if (relativePath.startsWith('/')) {\n        return `${indexUrl}/${appPageContext}${relativePath}`;\n    }\n    return `${indexUrl}/${appPageContext}/${relativePath}`;\n}","import { Session, db } from \"@root/db/db\";\nimport { openWindow, redirectTab } from \"./window-utils\";\n\nexport const getSessionRecord = async (sessionId: string) => {\n    const record = await db.sessions.get(sessionId);\n    if (! record) {\n        throw new Error('Unable to find session record by id ' + sessionId);\n    }\n    return record;\n}\n\n/**\n * For each Authentication/Registration session, we create one window.\n * For subsequent requests, we update the tab's URL of the existing window\n * to process the new requests. However, when a request is rejected, the window\n * is closed. As such, the initially created window/tab does not exist anymore.\n * For this, subsequent requests should call `openWindowOrRedirectTab` to either\n * redirect the existing tab (if present) or create a new one. This is only\n * applicable in the MODE_EXTERNAL_WINDOW mode. If a new window/tab is created,\n * we update the session record to reflect the new tab id.\n * @param sessionId\n * @param tabId\n * @param relativePath\n */\nexport const openWindowOrRedirectTab = async (\n    sessionId: string,\n    tabId: number,\n    relativePath: string\n) => {\n    try {\n        await browser.tabs.get(tabId);\n    } catch (e) {\n        // BRTTODO: Check if exception indicates a Tab Not Found error.\n        // no tab. create a window.\n        const window = await openWindow(relativePath);\n        // update session record to store the new tab id.\n        const newTabId = window.tabs![0].id!\n        const change: Pick<Session, 'tabId'> = { tabId: newTabId };\n        await db.sessions.update(sessionId, change);\n        return newTabId;\n    }\n    await redirectTab(tabId, relativePath);\n}","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\nimport type { BerytusChallengeAbortionCode, BerytusChallengeInfoUnion, BerytusFieldOptionsUnion, BerytusFieldUnion, BerytusFieldValue, BerytusFieldValueUnion, BerytusKeyDerivationParams, BerytusKeyExchangeAuthentication, BerytusKeyExchangeParams, BerytusKeyExchangeSession, BerytusKeyGenParams, BerytusReceiveMessageUnion, BerytusSendMessageUnion, BerytusUserAttributeDefinition, EBerytusChallengeType, EBerytusFieldType } from \"./generated/berytus.web.d.ts\";\n\nexport interface ChannelConstraints {\n    secretManagerPublicKey?: string[];\n    enableEndToEndEncryption: boolean;\n    account?: AccountConstraints;\n}\n\nexport interface PartialAccountIdentity {\n    fieldId: string;\n    fieldValue: string;\n}\n\nexport type AccountIdentity = Array<PartialAccountIdentity>;\n\nexport interface AccountConstraints {\n    category?: string;\n    schemaVersion?: number;\n    identity?: AccountIdentity;\n}\n\nexport interface ChannelMetadata {\n    id: string;\n    constraints: ChannelConstraints;\n    webAppActor: WebAppActor;\n    scmActor: CryptoActor; /* retrieved from getSigningKey() */\n}\n\nexport interface UriParams {\n    uri: string;\n    scheme: string;\n    hostname: string;\n    port: number;\n    path: string;\n};\n\nexport interface OriginActor {\n    originalUri: UriParams;\n    currentUri: UriParams;\n}\n\nexport interface CryptoActor {\n    ed25519Key: string;\n}\n\nexport interface Request {\n    id: string;\n    type: string;\n}\n\nexport interface DocumentMetadata {\n    id: number; /* e.g. tabId if sent to extensions */\n    uri: UriParams;\n}\n\nexport enum EOperationStatus {\n    Pending = \"Pending\",\n    Created = \"Created\",\n    Aborted = \"Aborted\",\n    Finished = \"Finished\"\n}\n\nexport enum EOperationType {\n    PendingDeclaration = \"PendingDeclaration\",\n    Registration = \"Registration\",\n    Authentication = \"Authentication\"\n}\n\nexport interface OperationState {}\n\nexport interface OperationMetadata {\n    id: string;\n    type: EOperationType;\n    status: EOperationStatus;\n    /**\n     * State about the operation, e.g.:\n     * { fields:  [BerytusIdentityField, ...], ... }\n     */\n    // TODO(berytus): This is currently unused.\n    state: OperationState;\n}\n\nexport interface FieldInfo {\n    id: string;\n    type: EBerytusFieldType;\n    // NOTE(berytus): ValidatedRequestHandler does not\n    // (yet) check if the options is logically conformant.\n    // Alternatively, type FieldInfo = Omit<BerytusFieldUnion, \"value\">\n    // -- however, type-parser would not be able to parse Omit<..>\n    // A better option is to generate *FieldInfoUnion\n    options: BerytusFieldOptionsUnion;\n}\n\nexport interface LoginOperationMetadata extends OperationMetadata {\n    intent: ELoginUserIntent;\n    requestedUserAttributes: RequestedUserAttributes;\n    fields: Record<string, FieldInfo>;\n    challenges: Record<string, BerytusChallengeInfoUnion>;\n}\n\n// TODO(berytus): Addd LoginOperation : *Metadata which includes state\n// about the fields created and so on.\n\nexport interface PreliminaryRequestContext {\n    request: Request;\n    document: DocumentMetadata;\n}\n\nexport interface RequestContext extends PreliminaryRequestContext {\n    channel: ChannelMetadata;\n}\n\nexport interface RequestContextWithOperation extends RequestContext {\n    operation: OperationMetadata;\n}\n\nexport interface RequestContextWithLoginOperation extends RequestContext {\n    operation: LoginOperationMetadata;\n}\n\nexport type CredentialsMetadata = number;\n\nexport enum ELoginUserIntent {\n    PendingDeclaration = \"PendingDeclaration\",\n    Authenticate = \"Authenticate\",\n    Register = \"Register\"\n}\n\nexport type WebAppActor = CryptoActor | OriginActor;\n\nexport interface GenerateX25519KeyResult {\n    public: string;\n};\n\nexport interface InitialKeyExchangeParametersDraft {\n    readonly channelId: string; // provided by Berytus\n    readonly webAppX25519Key: string; // provided by the web app\n}\n\n/**\n * What the SCM should return when generating\n * the key exch paramters.\n */\nexport interface PartialKeyExchangeParametersFromScm {\n    scmX25519Key: string;\n    hkdfHash: string; //hash name\n    hkdfSalt: ArrayBuffer;\n    hkdfInfo: ArrayBuffer;\n    aesKeyLength: number; // bits\n}\n\nexport interface KeyExchangeParameters\n    extends InitialKeyExchangeParametersDraft,\n            PartialKeyExchangeParametersFromScm {\n    /**\n     * This is what should be signed.\n     */\n    packet: string;\n}\n\nenum EChallengeType {\n    Identification = \"Identification\",\n    DigitalSignature = \"DigitalSignature\",\n    Password = \"Password\",\n    SecureRemotePassword = \"SecureRemotePassword\",\n    ForeignIdentityOtp = \"ForeignIdentityOtp\"\n}\n\nenum EChallengeStatus {\n    Invalid = \"Invalid\",\n    Pending = \"Pending\",\n    Active = \"Active\",\n    Aborted = \"Aborted\",\n    Sealed = \"Sealed\"\n}\n\nexport interface ChallengeParameters {}\n\nexport interface ChallengeMetadata {\n    readonly id: string;\n    readonly type: EChallengeType;\n    readonly parameters: ChallengeParameters;\n    readonly status: EChallengeStatus;\n}\n\nexport interface ChallengePayload {}\n\nexport interface ChallengeMessage {\n    /**\n     * Unique message name across the challenge.\n     */\n    name: string; // one of EMT{x}\n    payload: ChallengePayload;\n};\n\nexport interface ChallengeMessageResponse {\n    payload: ChallengePayload;\n};\n\nexport interface ChallengeAbortionReason {\n    /**\n     * TODO(berytus): Use string type instead of\n     * ChallengeAbortionCode UnionType until we can\n     * handle unions in schema generation using `choices`\n     */\n    code: string;\n}\n\n// TODO(berytus): Addd ChallengeDetail : ChallengeMetadata which includes state\n// about the fields created and so on.\n\nexport type UserAttributeKey = \"name\" | \"givenName\" | \"familyName\" | \"middleName\" |\n    \"nickname\" |/* \"preferredUsername\" |*/ \"profile\" | \"picture\" |\n    \"website\" |/* \"email\" |*/ \"gender\" | \"birthdate\" | \"zoneinfo\" |\n    \"locale\" |/* \"phoneNumber\" |*/ \"address\" | `custom:${string}`;\n\n\nexport interface UserAttribute extends BerytusUserAttributeDefinition {\n    id: UserAttributeKey;\n};\n\nexport interface RequestedUserAttribute {\n    id: UserAttributeKey;\n    required: boolean;\n}\n\nexport type UserAttributes = Array<UserAttribute>;\nexport type RequestedUserAttributes = Array<RequestedUserAttribute>;\n\nenum EFieldType {\n    Identity = \"Identity\",\n    ForeignIdentity = \"ForeignIdentity\",\n    Password = \"Password\",\n    SecurePassword = \"SecurePassword\",\n    Key = \"Key\"\n};\n\nexport interface BaseFieldMetadata {\n    fieldType: EFieldType;\n    fieldId: string;\n    description?: string;\n}\n\nexport interface FieldValueRejectionReason {\n    code: string;\n}\n\n// TODO(berytus): ERejectionCode should be in the API.\nexport enum ERejectionCode {\n    UnknownReason,\n    GeneralError,\n    NetworkError,\n    UserError,\n    OperationAborted,\n    /* begin challenge trap codes */\n    ChallengeNotSupported,\n    UnexpectedChallengeMessage,\n    InvalidChallengeMessage\n    /* end challenge trap codes */\n}\n\nenum EMetadataProperty {\n    Version = \"Version\",\n    Status = \"Status\",\n    Category = \"Category\",\n    ChangePassUrl = \"ChangePassUrl\"\n};\n\nexport enum EMetadataStatus {\n    Pending = \"Pending\",\n    Created = \"Created\",\n    Retired = \"Retired\",\n};\n\nexport interface RecordMetadata {\n    version: number;\n    status: EMetadataStatus;\n    category: string;\n    changePassUrl: string;\n}\n\n/* Request Arguments */\nexport type GetCredentialsMetadataArgs = {\n    webAppActor: WebAppActor,\n    channelConstraints: ChannelConstraints,\n    accountConstraints: AccountConstraints\n};\nexport type GetSigningKeyArgs = {\n    webAppActor: WebAppActor;\n};\nexport type GetSigningKeyResult = string;\n\nexport type CreateChannelArgs = {\n    channel: ChannelMetadata;\n};\n\nexport interface KeyAgreementParameters {\n    authentication: BerytusKeyExchangeAuthentication;\n    session: BerytusKeyExchangeSession;\n    exchange: BerytusKeyExchangeParams;\n    derivation: BerytusKeyDerivationParams;\n    generation: BerytusKeyGenParams;\n};\nexport type SignKeyAgreementParametersArgs = {\n    /**\n     * CanonicalJSON-stringified KeyAgreementParameters\n     */\n    canonicalJson: string;\n}\nexport type SignKeyAgreementParametersResult = {\n    scmSignature: ArrayBuffer;\n}\n\nexport type GenerateKeyExchangeParametersArgs = {\n    paramsDraft: InitialKeyExchangeParametersDraft\n}\nexport type VerifySignedKeyExchangeParametersArgs = {\n    /**\n     * CanonicalJSON-stringified KeyAgreementParameters\n     */\n    canonicalJson: string;\n    webAppSignature: ArrayBuffer;\n}\nexport type ApproveOperationArgs = {\n    operation: LoginOperationMetadata\n}\nexport type UpdateMetadataArgs = {\n    metadata: RecordMetadata\n}\n\nexport interface UpdateUserAttributesArgs {\n    userAttributes: Array<UserAttribute>;\n};\n\nexport type ApproveTransitionToAuthOpArgs = {\n    newAuthOp: LoginOperationMetadata\n}\nexport type AddFieldArgs = {\n    field: BerytusFieldUnion;\n}\n\n/**\n * The secret manager should resolve with null\n * when a field value was specified in the args.\n */\nexport type AddFieldResult = BerytusFieldValueUnion | null;\n\nexport type RejectFieldValueArgs = {\n    fieldId: string;\n    reason: FieldValueRejectionReason,\n    optionalNewValue?: BerytusFieldValueUnion;\n}\n\n/**\n * The secret manager should resolve with null\n * when a field value was specified in the args.\n */\nexport type RejectFieldResult = BerytusFieldValueUnion | null;\n\nexport type ApproveChallengeRequestArgs = {\n    challenge: BerytusChallengeInfoUnion;\n}\nexport type AbortChallengeArgs = {\n    challenge: BerytusChallengeInfoUnion;\n    reason: BerytusChallengeAbortionCode\n}\nexport type CloseChallengeArgs = {\n    challenge: BerytusChallengeInfoUnion;\n}\nexport type RespondToChallengeMessageArgs = BerytusSendMessageUnion;\nexport type { BerytusSendMessageUnion };\nexport type RespondToChallengeMessageResult = BerytusReceiveMessageUnion;\nexport type { BerytusReceiveMessageUnion };\nexport type { BerytusChallengeInfoUnion };\nexport { EBerytusChallengeType };\n/* Request Arguments */\n\nexport interface RequestHandler {\n    manager: {\n        getSigningKey(\n            context: PreliminaryRequestContext,\n            args: GetSigningKeyArgs\n        ): GetSigningKeyResult;\n        getCredentialsMetadata(\n            context: PreliminaryRequestContext,\n            args: GetCredentialsMetadataArgs\n        ): CredentialsMetadata;\n    };\n    channel: {\n        createChannel(\n            context: PreliminaryRequestContext,\n            args: CreateChannelArgs\n        ): void;\n        generateX25519Key(context: RequestContext): GenerateX25519KeyResult;\n        signKeyExchangeParameters(\n            context: RequestContext,\n            args: SignKeyAgreementParametersArgs\n        ): SignKeyAgreementParametersResult;\n        verifySignedKeyExchangeParameters(\n            context: RequestContext,\n            args: VerifySignedKeyExchangeParametersArgs\n        ): void;\n        enableEndToEndEncryption(context: RequestContext): void;\n        closeChannel(context: RequestContext): void;\n    };\n    /**\n     * Common requests between the account creation/registration\n     * operations, grouped under login.\n     */\n    login: {\n        approveOperation(\n            context: RequestContext,\n            args: ApproveOperationArgs\n        ): ELoginUserIntent;\n        closeOperation(\n            context: RequestContextWithOperation\n        ): void;\n        /* Berytus setPasswordUrl/setStatus/setVersion/setCategory: */\n        getRecordMetadata(\n            context: RequestContextWithOperation\n        ): RecordMetadata\n        updateMetadata(\n            context: RequestContextWithOperation,\n            args: UpdateMetadataArgs\n        ): void\n    },\n    accountCreation: {\n        approveTransitionToAuthOp(\n            context: RequestContextWithOperation,\n            args: ApproveTransitionToAuthOpArgs\n        ): void;\n        getUserAttributes(\n            context: RequestContextWithLoginOperation\n        ): UserAttributes;\n        updateUserAttributes(\n            context: RequestContextWithOperation,\n            args: UpdateUserAttributesArgs\n        ): void;\n        addField(\n            context: RequestContextWithLoginOperation,\n            args: AddFieldArgs\n        ): AddFieldResult;\n        rejectFieldValue(\n            context: RequestContextWithLoginOperation,\n            args: RejectFieldValueArgs\n        ): RejectFieldResult;\n    };\n    accountAuthentication: {\n        approveChallengeRequest(\n            context: RequestContextWithOperation,\n            args: ApproveChallengeRequestArgs\n        ): void;\n        abortChallenge(\n            context: RequestContextWithOperation,\n            args: AbortChallengeArgs\n        ): void;\n        closeChallenge(\n            context: RequestContextWithOperation,\n            args: CloseChallengeArgs,\n        ): void;\n        respondToChallengeMessage(\n            context: RequestContextWithLoginOperation,\n            args: RespondToChallengeMessageArgs\n        ): RespondToChallengeMessageResult;\n    }\n}\n\nexport type ResponseContext<G extends keyof RequestHandler, M extends keyof RequestHandler[G]> = {\n    response:\n        RequestHandler[G][M] extends (...args: any[]) => any\n        ? {\n            resolve: (val: ReturnType<RequestHandler[G][M]>) => void,\n            reject: (val: unknown) => void\n        }\n        : never\n}\n\nexport type IUnderlyingRequestHandler = {\n    [group in keyof RequestHandler]: {\n        [method in keyof RequestHandler[group]]:\n            RequestHandler[group][method] extends (...args: any[]) => any\n                ? Parameters<RequestHandler[group][method]> extends [infer context, ...infer tail]\n                    ? (context: context & ResponseContext<group,method> , ...rest: tail) => void\n                    : never\n                : never\n    }\n}\n\nexport type IPublicRequestHandler = {\n    [group in keyof RequestHandler]: {\n        [method in keyof RequestHandler[group]]:\n            RequestHandler[group][method] extends (...args: any[]) => any\n                ? Parameters<RequestHandler[group][method]> extends [infer context, ...infer tail]\n                    ?   (context: Omit<context, 'request'>, ...rest: tail) => Promise<ReturnType<RequestHandler[group][method]>>\n                    : never\n                : never\n    }\n}\n\nexport type RequestGroup = keyof RequestHandler;\nexport type RequestType = keyof {\n    [K in RequestGroup as `${Capitalize<K>}_${Capitalize<keyof RequestHandler[K] & string>}`]: true\n}\n\nexport type RequestHandlerFunction<ER extends RequestType> =\n    Uncapitalize<ER> extends `${infer G}_${infer T}`\n        ? G extends RequestGroup\n            ? Uncapitalize<T> extends `${infer M}`\n                ? M extends keyof RequestHandler[G]\n                    ? RequestHandler[G][M]\n                    : never\n                : never\n            : never\n    : never;\n\nexport type RequestHandlerFunctionParameters<ER extends RequestType>\n    = Parameters<RequestHandlerFunction<ER>>;\n\nexport type RequestHandlerFunctionReturnType<ER extends RequestType>\n    = Awaited<ReturnType<RequestHandlerFunction<ER>>>;","export function formatBase64AsPem(str: string, publicKey: boolean = true) {\n    const type = publicKey ? \"PUBLIC\" : \"PRIVATE\"\n    let res = `-----BEGIN ${type} KEY-----\\n`;\n\n    while(str.length > 0) {\n        res += str.substring(0, 64) + '\\n';\n        str = str.substring(64);\n    }\n\n    res = res + `-----END ${type} KEY-----`;\n\n    return res;\n}\nexport function formatSignatureBufToString(signedMessage: ArrayBuffer): string {\n    let hex = ab2base64(signedMessage);\n    let res = \"-----BEGIN CUSTOM SIGNATURE FORMAT -----\\n\";\n\n    while(hex.length > 0) {\n        res += hex.substring(0, 64) + '\\n';\n        hex = hex.substring(64);\n    }\n\n    res += \"----END CUSTOM SIGNATURE FORMAT -----\";\n    return res;\n}\n\nexport function extractPemBase64Body(pemStr: string, publicKey: boolean = true): string {\n    const type = publicKey ? \"PUBLIC\" : \"PRIVATE\"\n    const header = `-----BEGIN ${type} KEY-----\\n`;\n    const footer = `-----END ${type} KEY-----`;\n    if (! pemStr.startsWith(header)) {\n        throw new Error('Key does not start with \"'+header+'\"')\n    }\n    if (! pemStr.endsWith(footer)) {\n        throw new Error('Key does not end with \"'+footer+'\"')\n    }\n    const body = pemStr.substring(header.length, pemStr.length - footer.length);\n    const base64 = body.replace(/\\r?\\n|\\r/g, '');\n    return base64;\n}\n// TODO(berytus): Review this impl\nexport function pemToBuf(str: string, publicKey: boolean = true): ArrayBufferLike {\n    const base64 = extractPemBase64Body(str, publicKey);\n    return str2ab(atob(base64));\n}\n\nexport function bufToPem(buffer: ArrayBuffer, publicKey?: boolean) {\n    return formatBase64AsPem(ab2base64(buffer), publicKey);\n}\n\nexport function ab2str(buffer: ArrayBufferLike) {\n    return String.fromCharCode.apply(null, new Uint8Array(buffer) as any);\n}\n\nexport function str2ab(str: string): ArrayBufferLike {\n    return new TextEncoder().encode(str).buffer;\n}\n\nexport function ab2base64(buffer: ArrayBufferLike) {\n    return btoa(ab2str(buffer));\n}\n\nexport function decodeHex(hex: string): ArrayBufferLike {\n    if (hex.startsWith(\"0x\")) {\n        hex = hex.substring(2);\n    }\n    if (hex.length % 2 !== 0) {\n        throw new Error(\"Bad Hex.\");\n    }\n    const bytes = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < hex.length;) {\n        bytes[i / 2] = Number.parseInt(hex.slice(i, i += 2), 16);\n    }\n    return bytes.buffer;\n}\n\nexport async function privateKeyBufToPublicKeyBuf(privateKeyBuf: ArrayBufferLike): Promise<ArrayBuffer> {\n    const privateKey = await window.crypto.subtle.importKey(\n        \"pkcs8\",\n        privateKeyBuf instanceof ArrayBuffer\n            ? privateKeyBuf\n            : new Uint8Array(privateKeyBuf),\n        {\n            name: \"RSA-OAEP\",\n            hash: {name: \"SHA-256\"}\n        },\n        true,\n        [\"decrypt\"]\n    );\n    const privateKeyJwk = await window.crypto.subtle.exportKey('jwk', privateKey);\n    const publicKey = await window.crypto.subtle.importKey(\n        'jwk',\n        {\n            n: privateKeyJwk.n,\n            e: privateKeyJwk.e,\n            alg: privateKeyJwk.alg,\n            kty: privateKeyJwk.kty,\n        },\n        {\n            name: \"RSA-OAEP\",\n            hash: { name: \"SHA-256\" }\n        },\n        true,\n        [\"encrypt\"]\n    );\n    return window.crypto.subtle.exportKey('spki', publicKey);\n}\n\nexport function base64ToArrayBuffer(base64: string): ArrayBuffer {\n    const binaryString = atob(base64);\n    const bytes = new Uint8Array(binaryString.length);\n    for (let i = 0; i < binaryString.length; i++) {\n        bytes[i] = binaryString.charCodeAt(i);\n    }\n    return bytes.buffer;\n}","import type { UserAttributeKey } from \"@berytus/types\";\n\nexport const userAttributesLabels: Record<\n    UserAttributeKey, string\n> = {\n    \"name\": \"Full name\",\n    \"givenName\": \"First name\",\n    \"middleName\": \"Middle name\",\n    \"familyName\": \"Family name\",\n    \"nickname\": \"Nickname\",\n    \"gender\": \"Gender\",\n    \"birthdate\": \"Birthdate\",\n    \"locale\": \"Locale\",\n    \"address\": \"Address\",\n    \"profile\": \"Profile URL\",\n    \"picture\": \"Picture\",\n    \"website\": \"Website URL\",\n    \"zoneinfo\": \"Zoneinfo\"\n}","import { ab2base64 } from \"@root/key-utils\";\nimport type { ArrayBufferOrBerytusEncryptedPacket, BerytusEncryptedPacket, BerytusFieldUnion } from \"@berytus/types-extd\";\n\nexport const stringifyEncryptedPacket = (value: BerytusEncryptedPacket) => {\n    const parameters: Record<string, string | number | boolean | undefined> = {};\n    (Object.keys(value.parameters) as Array<keyof typeof value.parameters>).forEach(key => {\n        const prop = value.parameters[key];\n        if (prop === undefined || typeof prop === \"string\" || typeof prop === \"number\" || typeof prop === \"boolean\") {\n            parameters[key] = prop;\n            return;\n        }\n        if (prop instanceof ArrayBuffer) {\n            parameters[key] = ab2base64(prop);\n            return;\n        }\n        // TODO(berytus): Remove this when ArrayBufferViews are removed\n        parameters[key] = ab2base64(prop.buffer);\n    })\n    return JSON.stringify({\n        ciphertext: ab2base64(value.ciphertext),\n        parameters\n    })\n}\n\nexport const stringifyArrayBufferOrEncryptedPacket = (value: ArrayBufferOrBerytusEncryptedPacket) => {\n    if (value instanceof ArrayBuffer) {\n        return ab2base64(value);\n    }\n    return stringifyEncryptedPacket(value);\n}\n\nexport const stringifyFieldValue = (fieldValue: BerytusFieldUnion['value']) =>  {\n    if (typeof fieldValue === \"string\") {\n        return fieldValue;\n    }\n    if (fieldValue === null) {\n        return \"\";\n    }\n    if (\"salt\" in fieldValue) {\n        return JSON.stringify({\n            salt: stringifyArrayBufferOrEncryptedPacket(fieldValue.salt),\n            verifier: stringifyArrayBufferOrEncryptedPacket(fieldValue.verifier)\n        })\n    }\n    if (\"privateKey\" in fieldValue) {\n        return stringifyArrayBufferOrEncryptedPacket(fieldValue.privateKey);\n    }\n    if (\"publicKey\" in fieldValue) {\n        return stringifyArrayBufferOrEncryptedPacket(fieldValue.publicKey);\n    }\n    return stringifyArrayBufferOrEncryptedPacket(fieldValue);\n}","/**\n * browser.pageAction.openPopup() is a nuanced API.\n * - Cannot be called unless a user action status is set; fair.\n * - Would close a popup if it's open; making things difficult.\n *      - And, it's impossible to check whether the popup is already\n *        open without losing the user action status.\n * => Therefore, calling browser.pageAction.openPopup() whenever\n *    we want the user to resolve a request could potentially close\n *    an already open popup.\n *\n * In Berytus 0.1, I had implemented a WebExtension API for this purpose,\n * called openPageActionPopupIfNecessary (under browser.authrealm).\n * It had enabled extensions to open the popup, if necessary, only when\n * a request is pending and has not been resolved/reject yet. While this is\n * certainly not ideal to deploy for all extensions, it served as a remedy.\n *\n * In Berytus 0.2, I wrote the below code as a workaround without\n * relying on the introduction of a new WebExtensions API. Essentially,\n * the popup should send a message to the background script asking it\n * to resolve/reject the request. Here, the background script would\n * first hide the popup from the tab, ensuring that it is closed,\n * and it cannot be opened by the user, before resolving/rejecting the\n * request. Hence, whenever a new request comes from Berytus, the popup\n * is guaranteed to be closed, and browser.pageAction.openPopup() would\n * certainly open the popup. Sadly, this means that the popup page\n * should not directly call browser.berytus.(resolve/reject)Request.\n */\n\nimport { setPageActionUrlInTab } from \"./pageAction-utils\";\n\ninterface OpenOptions {\n    requestId: string;\n    tabId: number;\n}\n\nexport const openPageActionPopupIfNecessary = async ({ requestId, tabId }: OpenOptions, absolutePath: string) => {\n    browser.pageAction.show(tabId);\n    const prom0 = associateTabIdWithRequest(requestId, tabId);\n    const prom1 = setPageActionUrlInTab(tabId, absolutePath, false);\n    const prom2 = (browser.pageAction as any).openPopup();\n    await prom0;\n    await prom1;\n    await prom2;\n}\n\nconst tabDictKey = (requestId: string) => `tabdict:${requestId}`;\n\nconst associateTabIdWithRequest = async (requestId: string, tabId: number) => {\n    await browser.storage.session.set({\n        [tabDictKey(requestId)]: tabId\n    });\n}\n\nconst getAssociatedTabId = async (requestId: string): Promise<number | undefined> => {\n    const key = tabDictKey(requestId);\n    const res = await browser.storage.session.get(key);\n    return res[key];\n}\n\nconst deleteTabIdAssociation = async (requestId: string): Promise<void> => {\n    await browser.storage.session.remove(tabDictKey(requestId));\n}\n\ntype MessageRequests = {\n    type: \"resolveRequest\" | \"rejectRequest\"\n    data: {\n        requestId: string;\n        value: unknown\n    }\n} /* | ... */\n\nbrowser.runtime.onMessage.addListener(\n    function(request: MessageRequests, sender, sendResponse) {\n        console.log(\"onMessage:\", request, sender)\n        if (sender.id !== \"secretstar@alichry\") {\n            return;\n        }\n        const hide = async () => {\n            const tabId = await getAssociatedTabId(request.data.requestId);\n            if (! tabId) {\n                console.warn(\"secretstar: can't hide popup, tabId undefined.\");\n                return;\n            }\n            try {\n                await Promise.resolve(browser.pageAction.hide(tabId));\n            } catch (e) {\n                console.warn(\"secretstar: error hiding popup:\");\n                console.error(e)\n            } finally {\n                await deleteTabIdAssociation(request.data.requestId);\n            }\n        }\n        const send = async (type: \"resolve\" | \"reject\") => {\n            try {\n                await (\n                    type === \"resolve\"\n                        ? browser.berytus.resolveRequest(request.data.requestId, request.data.value)\n                        : browser.berytus.rejectRequest(request.data.requestId, request.data.value)\n                );\n                console.debug(\"secretstar@alichry: settled request\", request.data.requestId);\n            } catch (e) {\n                console.warn(\"secretstar: error resolving request:\");\n                console.error(e);\n            }\n        }\n        if (request.type === \"resolveRequest\") {\n            hide().then(() => send(\"resolve\"));\n            sendResponse();\n            return;\n        }\n        if (request.type === \"rejectRequest\") {\n            hide().then(() => send(\"reject\"));\n            sendResponse();\n            return;\n        }\n    }\n);","import { PAGECONTEXT_POPUP } from '@root/pagecontext';\nimport { url, paths } from './paths';\n\nexport function setPageActionUrlInTab(\n    tabIdWherePageActionIs: number,\n    path: string,\n    relative = true\n) {\n    return browser.pageAction.setPopup({\n        tabId: tabIdWherePageActionIs,\n        popup: relative\n            ? url(path, PAGECONTEXT_POPUP)\n            : path\n    });\n}\n\nexport function setPageActionToLoadingPage(tabIdWherePageActionIs: number) {\n    return setPageActionUrlInTab(tabIdWherePageActionIs, paths.loading);\n}\n\n/**\n * browser.pageAction.openPopup() has several limitations:\n * 1. It only opens up the page action popup in the selected tab.\n * 2. If the popup is already open, it closes it. Making it difficult\n * to open the popup if necessary.\n * 3. If we wish to highlight the relevant tab where the popup should open,\n * we lose the `user action` status since doing so is asynchronous, and\n * we cannot open the popup unless the correct tab is highlighted.\n * We have created browser.authRealm.openPageActionPopupIfNecessary\n * to open the popup in the relevant tab (the tab belonging to the authRealm\n * session).\n * @param tabIdWherePageActionIs\n */\nexport async function openPageActionInTabId(tabIdWherePageActionIs: number) {\n    const tab = await browser.tabs.get(tabIdWherePageActionIs);\n    await browser.tabs.highlight({ windowId: tab.windowId, tabs: [tab.index] });\n    // Firefox only.\n    (browser.pageAction as any).openPopup();\n}","import { Session, db } from \"@root/db/db\";\nimport { MODE, MODE_EXTERNAL_WINDOW } from \"../env\";\nimport { openWindow } from \"./window-utils\";\nimport { getSessionRecord, openWindowOrRedirectTab } from \"./session-utils\";\nimport { url } from \"./paths\";\nimport { randomPassword } from \"@root/utils\";\nimport { PAGECONTEXT_POPUP } from \"@root/pagecontext\";\nimport { ab2base64, base64ToArrayBuffer } from \"@root/key-utils\";\nimport { Channel, isChannelE2EReady } from \"@root/db/Channel\";\nimport { ERejectionCode, EOperationType, EMetadataStatus, RequestType } from \"@berytus/enums\";\nimport type { KeyAgreementParameters, PreliminaryRequestContext } from \"@berytus/types\";\nimport { userAttributesLabels } from \"@root/ui/utils/userAttributesLabels\";\nimport { stringifyArrayBufferOrEncryptedPacket, stringifyEncryptedPacket } from \"./field-utils\";\nimport { openPageActionPopupIfNecessary } from \"./pageAction-popup-fix\";\n\nconsole.debug(\"secretstar(bg): loaded\");\n\nconst plainContext = (context: PreliminaryRequestContext) => {\n    return {\n        ...context,\n        response: undefined,\n    }\n}\n\nasync function printSessionForSimiluationPrep(\n    phase: RequestType | `${RequestType}:${string}`,\n    sessionId: string\n) {\n    // const session = await getSessionRecord(sessionId);\n    // console.log('simulate:', JSON.stringify({\n    //     phase, session\n    // }, null, 2));\n}\n\nasync function printSessionWithChannelForSimulationPrep(\n    phase: RequestType,\n    sessionId: string\n) {\n    // const session = await getSessionRecord(sessionId);\n    // const channel = await db.channel.get(session.channel.id);\n    // if (! channel) {\n    //     throw new Error('Cant find channel to print simulation prep');\n    // }\n    // console.log('simulate', phase, JSON.stringify({\n    //     session,\n    //     channel\n    // }, null, 2));\n}\n\nasync function showUi(\n    context: PreliminaryRequestContext,\n    sessionId: string,\n    relativePath: string,\n    sessionRecordPromise?: ReturnType<typeof getSessionRecord>\n) {\n    if (MODE === MODE_EXTERNAL_WINDOW) {\n        const { tabId } = await (sessionRecordPromise || getSessionRecord(sessionId));\n        if (! tabId) {\n            console.error('Secret* is in External Mode but session record had no tab id');\n            browser.berytus.rejectRequest(context.request.id, ERejectionCode.GeneralError);\n            return;\n        }\n        await openWindowOrRedirectTab(sessionId, tabId, relativePath);\n        return;\n    }\n    openPageActionPopupIfNecessary(\n        { requestId: context.request.id, tabId: context.document.id },\n        url(relativePath, PAGECONTEXT_POPUP)\n    );\n}\n\nbrowser.berytus.registerRequestHandler({\n    manager: {\n        async getSigningKey(context, args): Promise<void> {\n            const keys = await db.signingKeys.toArray();\n            if (keys.length > 0) {\n                context.response.resolve(keys[0].public);\n                return;\n            }\n            const keyPair = await window.crypto.subtle.generateKey(\n                \"Ed25519\",\n                true,\n                ['sign', 'verify']\n            ) as CryptoKeyPair;\n            const publicKey = ab2base64(\n                await window.crypto.subtle.exportKey(\"spki\", keyPair.publicKey)\n            );\n            await db.signingKeys.add({\n                public: publicKey,\n                private: await window.crypto.subtle.exportKey(\"pkcs8\", keyPair.privateKey)\n            })\n            context.response.resolve(publicKey);\n        },\n        async getCredentialsMetadata(context, args): Promise<void> {\n            const accounts = db.findCorrespondingAccounts(\n                args.webAppActor,\n                args.accountConstraints.category,\n                args.accountConstraints.schemaVersion\n            );\n            context.response.resolve(await accounts.count());\n        },\n    },\n    channel: {\n        async createChannel(context, args) {\n            const key = await db.signingKeys.get(args.channel.scmActor.ed25519Key);\n            if (! key) {\n                throw new Error(\n                    'Unable to find signing key '\n                    + args.channel.scmActor.ed25519Key\n                );\n            }\n            await db.channel.add({\n                id: args.channel.id,\n                scmEd25519: key,\n                webAppEd25519Pub: \"ed25519Key\" in args.channel.webAppActor\n                    ? args.channel.webAppActor.ed25519Key\n                    : undefined,\n                e2eeActvie: false\n            });\n            context.response.resolve();\n        },\n        async generateX25519Key(context) {\n            const channel = await db.channel.get(context.channel.id);\n            if (! channel) {\n                throw new Error('Unable to find channel by id ' + context.channel.id);\n            }\n            if (channel.scmX25519) {\n                throw new Error(\"Expecting our scm x25519 key to be unset; got otherwise.\");\n            }\n            const scmX25519Key = await window.crypto.subtle.generateKey(\n                \"X25519\",\n                true,\n                [\"deriveKey\"],\n            ) as CryptoKeyPair;\n            const b64Spki = ab2base64(\n                await window.crypto.subtle.exportKey(\"spki\", scmX25519Key.publicKey)\n            );\n            const change: Pick<Channel, 'scmX25519'> = {\n                scmX25519: {\n                    private: await window.crypto.subtle.exportKey(\"pkcs8\", scmX25519Key.privateKey),\n                    public: b64Spki\n                }\n            };\n            await db.channel.update(channel, change);\n            context.response.resolve({\n                public: b64Spki\n            });\n        },\n        async verifySignedKeyExchangeParameters(context, args): Promise<void> {\n            const channel = await db.channel.get(context.channel.id);\n            if (! channel) {\n                throw new Error('Unable to find channel by id ' + context.channel.id);\n            }\n            if (! channel.scmEd25519) {\n                throw new Error('Expecting our scm Ed25519 to be set; got otherwise.');\n            }\n            if (! channel.scmX25519) {\n                throw new Error('Expecting our scm X25519 to be set; got otherwise.');\n            }\n            if (channel.keyAgreement) {\n                throw new Error('Expecting key agreement parameters to be unset; got otherwise.');\n            }\n            if (! channel.webAppEd25519Pub) {\n                throw new Error('Expecting channel to have a crypto web app actor set; got otherwise.');\n            }\n            const parameters: KeyAgreementParameters = (() => {\n                const obj = JSON.parse(args.canonicalJson);\n                obj.session.fingerprint.salt =\n                    new Uint8Array(obj.session.fingerprint.salt).buffer;\n                obj.session.fingerprint.value =\n                    new Uint8Array(obj.session.fingerprint.value).buffer;\n                obj.derivation.salt =\n                    new Uint8Array(obj.derivation.salt).buffer;\n                obj.derivation.info =\n                    new Uint8Array(obj.derivation.info).buffer;\n                return obj;\n            })();\n            if (parameters.authentication.public.scm !== channel.scmEd25519.public) {\n                throw new Error(\"Crypto scm actor mismatch\");\n            }\n            if (parameters.authentication.public.webApp !== channel.webAppEd25519Pub) {\n                throw new Error(\"Crypto web app actor mismatch\");\n            }\n            if (parameters.exchange.public.scm !== channel.scmX25519.public) {\n\n                throw new Error(\"Scm X25519 mismatch\");\n            }\n            const webAppKey = await crypto.subtle.importKey(\n                'spki',\n                base64ToArrayBuffer(parameters.authentication.public.webApp),\n                'Ed25519',\n                false,\n                ['verify']\n            );\n            const data = new TextEncoder().encode(args.canonicalJson);\n            const valid = await crypto.subtle.verify(\n                'Ed25519',\n                webAppKey,\n                args.webAppSignature,\n                data\n            );\n            if (! valid) {\n                context.response.reject(ERejectionCode.GeneralError);\n                return;\n            }\n            const change: Pick<Channel, 'keyAgreement'> = {\n                keyAgreement: {\n                    parameters,\n                    signatures: {\n                        canonicalJson: args.canonicalJson,\n                        webAppSignature: args.webAppSignature\n                    },\n                }\n            };\n            await db.channel.update(channel, change);\n            context.response.resolve();\n        },\n        async signKeyExchangeParameters(context, args) {\n            const channel = await db.channel.get(context.channel.id);\n            if (! channel) {\n                throw new Error('Unable to find channel by id ' + context.channel.id);\n            }\n            if (! channel.scmEd25519) {\n                throw new Error('Expecting our scm ed25519Key to have been genenrated');\n            }\n            if (! channel.scmX25519) {\n                throw new Error('Expecting our scm scmX25519 to have been genenrated');\n            }\n            if (! channel.webAppEd25519Pub) {\n                throw new Error('Expecting web app ed25519 to have been given previously');\n            }\n            if (! channel.keyAgreement) {\n                throw new Error('Expecting key agreement parameters to be set; got otherwise.');\n            }\n            if (channel.keyAgreement.signatures.scmSignature) {\n                throw new Error('Expecting our scm signature to be unset; got otherwise.');\n            }\n            if (channel.keyAgreement.signatures.canonicalJson !== args.canonicalJson) {\n                throw new Error('Expecting our stored key agreement JSON to match what was provided; got otherwise.');\n            }\n            const ed25519Key = await window.crypto.subtle.importKey(\n                'pkcs8',\n                channel.scmEd25519.private,\n                \"Ed25519\",\n                false,\n                ['sign']\n            );\n            const scmSignature = await window.crypto.subtle.sign(\n                \"Ed25519\",\n                ed25519Key,\n                new TextEncoder().encode(args.canonicalJson)\n            );\n            await db.channel.update(channel, {\n                'keyAgreement.signatures.scmSignature': scmSignature\n            });\n            context.response.resolve({\n                scmSignature\n            });\n        },\n        async enableEndToEndEncryption(context): Promise<void> {\n            // TODO(berytus): It seems showUi depends on a session id\n            // (the operation id) retrieved from approveOperation.\n            // Once we refactor showUi to accept a channel id instead,\n            // we can consider showing a UI fo enableE2EE\n            // let window: chrome.windows.Window | undefined = undefined;\n            // const relativePath = `enable-e2e/${context.channel.id}/${context.request.id}/${context.request.type}`;\n            // if (MODE === MODE_EXTERNAL_WINDOW) {\n            //     window = await openWindow(relativePath);\n            // } else {\n            //     openPageActionPopupIfNecessary(\n            //         { requestId: context.request.id, tabId: context.document.id },\n            //         url(relativePath, PAGECONTEXT_POPUP)\n            //     );\n            // }\n            const channel = await db.channel.get(context.channel.id);\n            if (! channel) {\n                throw new Error('Expecting channel to be created; got otherwise.');\n            }\n            if (! isChannelE2EReady(channel)) {\n                throw new Error('Expecting channel to be E2E ready; got otherwise.');\n            }\n            const webAppKey = await crypto.subtle.importKey(\n                'spki',\n                // @ts-ignore: NOTE(berytus): Firefox only\n                Uint8Array.fromBase64(channel.keyAgreement.parameters.exchange.public.webApp),\n                'X25519',\n                false,\n                []\n            );\n            const scmKey = await window.crypto.subtle.importKey(\n                'pkcs8',\n                channel.scmX25519.private,\n                \"X25519\",\n                false,\n                ['deriveKey']\n            );\n            const sharedKey = await crypto.subtle.deriveKey(\n                {\n                    name: \"X25519\",\n                    public: webAppKey\n                },\n                scmKey,\n                'HKDF',\n                false,\n                ['deriveKey']\n            );\n            const encryptionKey = await crypto.subtle.deriveKey(\n                channel.keyAgreement.parameters.derivation,\n                sharedKey,\n                channel.keyAgreement.parameters.generation,\n                true,\n                ['encrypt', 'decrypt']\n            );\n            const change: Pick<Channel, 'e2eeActvie' | 'e2eeKey'> = {\n                e2eeActvie: true,\n                e2eeKey: await window.crypto.subtle.exportKey(\n                    \"raw\",\n                    encryptionKey\n                )\n            };\n            await db.channel.update(channel.id, change);\n            context.response.resolve();\n        },\n        closeChannel: function (context): void {\n            context.response.resolve();\n        }\n    },\n    login: {\n        async approveOperation(context, args): Promise<void> {\n            let window: chrome.windows.Window | undefined = undefined;\n            const relativePath = `intent/${args.operation.id}/0`;\n            if (MODE === MODE_EXTERNAL_WINDOW) {\n                window = await openWindow(relativePath);\n            } else {\n                openPageActionPopupIfNecessary(\n                    { requestId: context.request.id, tabId: context.document.id },\n                    url(relativePath, PAGECONTEXT_POPUP)\n                );\n            }\n            await db.sessions.add({\n                id: args.operation.id,\n                requests: [context.request],\n                channel: context.channel,\n                operation: args.operation,\n                context: plainContext(context),\n                tabId: window?.tabs ? window.tabs[0].id : undefined,\n                metadata: {\n                    version: context.channel.constraints.account?.schemaVersion || 0,\n                    status: EMetadataStatus.Pending,\n                    category: context.channel.constraints.account?.category || \"\",\n                    changePassUrl: \"\"\n                },\n                version: 1\n            });\n            printSessionForSimiluationPrep('Login_ApproveOperation', args.operation.id);\n        },\n        async closeOperation(context): Promise<void> {\n            const accountId = randomPassword();\n            const sessionId = context.operation.id;\n            const sessionRecordPromise = getSessionRecord(sessionId);\n            if (context.operation.type === EOperationType.Registration) {\n                const relativePath = `save/${sessionId}/${accountId}`;\n                await showUi(context, sessionId, relativePath, sessionRecordPromise);\n                const sessionRecord = await sessionRecordPromise;\n                const newAccountId = await db.accounts.add({\n                    id: accountId,\n                    date: new Date().toISOString(),\n                    registrationUri: context.document.uri,\n                    fields: sessionRecord.fields || [],\n                    webAppActor: context.channel.webAppActor,\n                    userAttributes: sessionRecord.userAttributes || {},\n                    metadata: sessionRecord.metadata\n                });\n                const change: Pick<Session, 'createdAccountId' | 'requests' | 'version' | 'closed'> = {\n                    createdAccountId: newAccountId as string, // BRTTODO: Perhaps change ids from strings to IndexableType for all references.\n                    requests: sessionRecord.requests.concat(context.request),\n                    version: sessionRecord.version + 1,\n                    closed: true\n                };\n                await db.sessions.update(sessionId, change);\n            } else {\n                const relativePath = `auth/${sessionId}/finished`;\n                await showUi(context, sessionId, relativePath, sessionRecordPromise);\n\n                const sessionRecord = await sessionRecordPromise;\n                const change: Pick<Session, 'requests' | 'version' | 'closed'> = {\n                    requests: sessionRecord.requests.concat(context.request),\n                    version: sessionRecord.version + 1,\n                    closed: true\n                };\n                await db.sessions.update(sessionId, change);\n            }\n            printSessionForSimiluationPrep(\"Login_CloseOperation\", sessionId);\n        },\n        async getRecordMetadata(context): Promise<void> {\n            const sessionId = context.operation.id;\n            const sessionRecord = await getSessionRecord(sessionId);\n            if (context.operation.type === EOperationType.Registration) {\n                context.response.resolve(sessionRecord.metadata);\n                return;\n            }\n            const account = await db.accounts.get(sessionRecord.selectedAccountId!);\n            if (! account) {\n                throw new Error('unable to get account record, the account id does not exist.');\n            }\n            context.response.resolve(account.metadata);\n        },\n        async updateMetadata(context, args): Promise<void> {\n            const sessionId = context.operation.id;\n            const sessionRecord = await getSessionRecord(sessionId);\n            const change: Pick<Session, 'metadata' | 'version'> = {\n                metadata: {\n                    ...sessionRecord.metadata,\n                    ...args.metadata\n                },\n                version: sessionRecord.version + 1\n            };\n            await db.sessions.update(sessionRecord, change);\n            context.response.resolve();\n        }\n    },\n    accountCreation: {\n        async approveTransitionToAuthOp(context, args): Promise<void> {\n            const currSessionId = context.operation.id;\n            const nextSessionId = args.newAuthOp.id;\n            const currSessionRecordPromise = getSessionRecord(currSessionId);\n            const relativePath = `transition-to-auth-op/${currSessionId}/${nextSessionId}`;\n            await showUi(context, currSessionId, relativePath, currSessionRecordPromise);\n\n            const currSession = await currSessionRecordPromise;\n            if (! currSession.createdAccountId) {\n                throw new Error(\"Expecting createdAccountId to be set when transitioning!\");\n            }\n            const account = await db.accounts.get(currSession.createdAccountId);\n            if (! account) {\n                throw new Error(\"Expecting account to be created before transitioning.\");\n            }\n            await db.sessions.add({\n                id: nextSessionId,\n                channel: context.channel,\n                operation: args.newAuthOp,\n                requests: [context.request],\n                transitionedFromSessionId: currSessionId,\n                context: plainContext(context),\n                tabId: currSession.tabId, // window tab id. not the content page tab id.\n                selectedAccountId: currSession.createdAccountId,\n                metadata: account.metadata,\n                version: 1,\n            });\n            printSessionForSimiluationPrep('AccountCreation_ApproveTransitionToAuthOp', nextSessionId);\n        },\n        async getUserAttributes(context): Promise<void> {\n            const sessionId = context.operation.id;\n            const sessionRecordPromise = getSessionRecord(sessionId);\n            {/* BRTTODO: 23/1/2024 Remove afterVersion -- this seems to be problematic. We should refactor how we process requests to use request id instead */}\n            const relativePath = `get-user-attributes/${sessionId}/1`;\n            await showUi(context, sessionId, relativePath, sessionRecordPromise);\n            const sessionRecord = await sessionRecordPromise;\n            const requiredUserAttributes: Partial<Record<keyof typeof userAttributesLabels, boolean>> = {};\n            (Object.keys(userAttributesLabels) as Array<keyof typeof userAttributesLabels>)\n                .map(key => {\n                    requiredUserAttributes[key] = false;\n                });\n            context.operation.requestedUserAttributes.forEach(({ id, required }) => {\n                requiredUserAttributes[id] = required;\n            });\n            const change: Pick<Session, 'requests' | 'requiredUserAttributes' | 'version'> = {\n                requiredUserAttributes: requiredUserAttributes as Record<keyof typeof userAttributesLabels, boolean>,\n                requests: sessionRecord.requests.concat(context.request),\n                version: 2\n            };\n            await db.sessions.update(sessionId, change);\n            printSessionForSimiluationPrep('AccountCreation_GetUserAttributes', sessionId);\n        },\n        updateUserAttributes(context, args): void {\n            throw new Error(\"Function not implemented.\");\n        },\n        async addField(context, args): Promise<void> {\n            const sessionId = context.operation.id;\n            const sessionRecordPromise = getSessionRecord(sessionId);\n            if (args.field.value === null) {\n                const relativePath = `create-field/${sessionId}/${args.field.id}`;\n                await showUi(context, sessionId, relativePath, sessionRecordPromise);\n                const sessionRecord = await sessionRecordPromise;\n                if (\n                    sessionRecord.createFieldOptions &&\n                    sessionRecord.createFieldOptions.find(o => o.id === args.field.id)\n                ) {\n                    browser.berytus.rejectRequest(context.request.id, ERejectionCode.GeneralError);\n                    return;\n                }\n                const change: Pick<Session, 'requests' | 'createFieldOptions' | 'version'> = {\n                    requests: sessionRecord.requests.concat(context.request),\n                    createFieldOptions: (sessionRecord.createFieldOptions || []).concat({\n                        id: args.field.id,\n                        type: args.field.type,\n                        options: args.field.options\n                    }),\n                    version: sessionRecord.version + 1\n                };\n                await db.sessions.update(sessionId, change);\n                printSessionForSimiluationPrep('AccountCreation_AddField', sessionId);\n                return;\n            }\n            const relativePath = `put-field/${sessionId}/${args.field.id}`;\n            await showUi(context, sessionId, relativePath, sessionRecordPromise);\n            const sessionRecord = await sessionRecordPromise;\n            if (\n                sessionRecord.putFields?.find(o => o.id === args.field.id)\n            ) {\n                browser.berytus.rejectRequest(context.request.id, ERejectionCode.GeneralError);\n                return;\n            }\n            if (args.field.type === \"Key\" || args.field.type === \"SecurePassword\") {\n                console.warn(\"PutField of type Key or SecurePassword are not allowed.\");\n                // TODO(berytus): Implement a logical validator in ValidatedRequestHandler\n                browser.berytus.rejectRequest(context.request.id, ERejectionCode.GeneralError);\n                return;\n            }\n            const change: Pick<Session, 'requests' | 'putFields' | 'version'> = {\n                requests: sessionRecord.requests.concat(context.request),\n                putFields: (sessionRecord.putFields || []).concat({\n                    id: args.field.id,\n                    type: args.field.type,\n                    options: args.field.options,\n                    value: args.field.type === \"SharedKey\"\n                        ? stringifyArrayBufferOrEncryptedPacket(args.field.value.privateKey)\n                        : typeof args.field.value === \"string\"\n                            ? args.field.value\n                            : stringifyEncryptedPacket(args.field.value)\n                }),\n                version: sessionRecord.version + 1\n            };\n            await db.sessions.update(sessionId, change);\n            printSessionForSimiluationPrep('AccountCreation_AddField:Put', sessionId);\n        },\n        async rejectFieldValue(context, args): Promise<void> {\n            const sessionId = context.operation.id;\n            const sessionRecordPromise = getSessionRecord(sessionId);\n\n            const relativePath = `create-field/${sessionId}/${args.fieldId}/rejected`;\n            await showUi(context, sessionId, relativePath, sessionRecordPromise);\n            const sessionRecord = await sessionRecordPromise;\n            const field = sessionRecord.fields?.find(f => f.id === args.fieldId);\n            const rejectedFieldValueIndex = sessionRecord.rejectedFieldValues?.findIndex(f => f.fieldId === args.fieldId);\n            if (\n                !sessionRecord.createFieldOptions?.find(o => o.id === args.fieldId) ||\n                !field\n            ) {\n                browser.berytus.rejectRequest(context.request.id, ERejectionCode.GeneralError);\n                return;\n            }\n            if (\n                typeof args.optionalNewValue === \"object\" && (\n                    \"publicKey\" in args.optionalNewValue ||\n                    \"salt\" in args.optionalNewValue\n                )\n            ) {\n                console.warn(\"RejectField of type Key or SecurePassword are not allowed.\");\n                // TODO(berytus): Implement a logical validator in ValidatedRequestHandler\n                browser.berytus.rejectRequest(context.request.id, ERejectionCode.GeneralError);\n                return;\n            }\n            if (\n                typeof args.optionalNewValue === \"object\" &&\n                args.optionalNewValue !== null &&\n                \"ciphertext\" in args.optionalNewValue) {\n                console.warn(\"TODO(berytus): handle encrypted values\");\n                browser.berytus.rejectRequest(context.request.id, ERejectionCode.GeneralError);\n                return;\n            }\n            let change: Pick<Session, 'requests' | 'rejectedFieldValues' | 'version'>;\n            let sameValue = false;\n            let value = undefined;\n            do {\n                if (! args.optionalNewValue) {\n                    break;\n                }\n                if (typeof args.optionalNewValue === \"string\") {\n                    sameValue = args.optionalNewValue === field.value;\n                    value = args.optionalNewValue;\n                    break;\n                }\n                if (args.optionalNewValue.privateKey instanceof ArrayBuffer) {\n                    value =  ab2base64(args.optionalNewValue.privateKey);\n                    sameValue = value === field.value;\n                    break;\n                }\n                console.warn(\"TODO(berytus): handle encrypted values\");\n            } while (false);\n            if (sameValue) {\n                // BRTTODO: A web app can reject a field value while dictating its new\n                // value the same as the previous one (the one being rejected). This\n                // should not happen, but since the AuthRealm API does not\n                // store field values, it cannot validate whether the optionalNewValue\n                // is different than the rejected one (or previously rejected).\n                // So for now, we throw an error here.\n                console.error('BRTTODO: WebApp rejected field value with an new value that equals the rejected one. Genuis.');\n                throw new Error('Unable to rejectRegistrationField. WebApp rejected the field value with an invalid new value.');\n            }\n            if (rejectedFieldValueIndex === undefined || rejectedFieldValueIndex === -1) {\n                change = {\n                    requests: sessionRecord.requests.concat(context.request),\n                    rejectedFieldValues: (sessionRecord.rejectedFieldValues || []).concat({\n                        fieldId: args.fieldId,\n                        code: args.reason.code,\n                        webAppDictatedValue: value,\n                        previousValues: [field.value]\n                    }),\n                    version: sessionRecord.version + 1\n                };\n            } else {\n                if (sessionRecord.rejectedFieldValues![rejectedFieldValueIndex].webAppDictatedValue) {\n                    throw new Error('This field has been rejected and overriden previously!');\n                }\n                sessionRecord.rejectedFieldValues![rejectedFieldValueIndex].webAppDictatedValue =\n                    value;\n                sessionRecord.rejectedFieldValues![rejectedFieldValueIndex].previousValues.push(\n                    field.value\n                );\n                change = {\n                    requests: sessionRecord.requests.concat(context.request),\n                    rejectedFieldValues: sessionRecord.rejectedFieldValues!,\n                    version: sessionRecord.version + 1\n                };\n            }\n            await db.sessions.update(sessionId, change);\n            printSessionForSimiluationPrep('AccountCreation_RejectFieldValue', sessionId);\n        }\n    },\n    accountAuthentication: {\n        async approveChallengeRequest(context, args): Promise<void> {\n            const sessionId = context.operation.id;\n            const sessionRecordPromise = getSessionRecord(sessionId);\n            const challengeId = args.challenge.id;\n            const relativePath = `auth/${sessionId}/challenge/${challengeId}/approve`;\n\n            await showUi(context, sessionId, relativePath, sessionRecordPromise);\n            const sessionRecord = await sessionRecordPromise;\n            const change: Pick<Session, 'challenges' | 'requests' | 'version'> = {\n                challenges: {\n                    ...sessionRecord.challenges,\n                    [challengeId]: {\n                        ...args.challenge,\n                        messages: {}\n                    }\n                },\n                requests: sessionRecord.requests.concat(context.request),\n                version: sessionRecord.version + 1\n            };\n\n            await db.sessions.update(sessionRecord, change);\n            printSessionForSimiluationPrep('AccountAuthentication_ApproveChallengeRequest', sessionId);\n        },\n        async abortChallenge(context, args): Promise<void> {\n            const sessionId = context.operation.id;\n            const sessionRecordPromise = getSessionRecord(sessionId);\n            const challengeId = args.challenge.id;\n            const relativePath = `auth/${sessionId}/challenge/${challengeId}/aborted`;\n\n            await showUi(context, sessionId, relativePath, sessionRecordPromise);\n            const sessionRecord = await sessionRecordPromise;\n            await db.sessions.update(sessionRecord, {\n                requests: sessionRecord.requests.concat(context.request),\n                [`challenges.${challengeId}.closed`]: true,\n                [`challenges.${challengeId}.abortionReasonCode`]: args.reason\n            });\n            printSessionForSimiluationPrep('AccountAuthentication_AbortChallenge', sessionId);\n        },\n        async closeChallenge(context, args): Promise<void> {\n            const sessionId = context.operation.id;\n            const sessionRecordPromise = getSessionRecord(sessionId);\n            const challengeId = args.challenge.id;\n            const relativePath = `auth/${sessionId}/challenge/${challengeId}/sealed`;\n\n            await showUi(context, sessionId, relativePath, sessionRecordPromise);\n            const sessionRecord = await sessionRecordPromise;\n            await db.sessions.update(sessionRecord, {\n                requests: sessionRecord.requests.concat(context.request),\n                [`challenges.${challengeId}.closed`]: true\n            });\n            printSessionForSimiluationPrep('AccountAuthentication_CloseChallenge', sessionId);\n        },\n        async respondToChallengeMessage(context, args): Promise<void> {\n            const sessionId = context.operation.id;\n            const sessionRecordPromise = getSessionRecord(sessionId);\n            const challengeId = args.challenge.id;\n            const messageId = args.name;\n            const relativePath = `auth/${sessionId}/challenge/${challengeId}/message/${messageId}`;\n\n            await showUi(context, sessionId, relativePath, sessionRecordPromise);\n            const sessionRecord = await sessionRecordPromise;\n            let payload;\n            if (typeof args.payload === \"string\") {\n                payload = args.payload;\n            } else if (args.payload instanceof ArrayBuffer) {\n                payload = ab2base64(args.payload);\n            } else if (ArrayBuffer.isView(args.payload)) {\n                console.warn(\"TODO(berytus): Remove ArrayBufferView support\");\n                context.response.reject(ERejectionCode.GeneralError);\n                return;\n            } else if (Array.isArray(args.payload)) {\n                payload = args.payload;\n            } else {\n                console.warn(\"TODO(berytus): Support Encrypted Packet\");\n                context.response.reject(ERejectionCode.GeneralError);\n                return;\n            }\n            await db.sessions.update(sessionRecord, {\n                [`challenges.${challengeId}.messages.${messageId}`]: {\n                    name: messageId,\n                    payload\n                },\n                requests: sessionRecord.requests.concat(context.request),\n                version: sessionRecord.version + 1\n            });\n            printSessionForSimiluationPrep('AccountAuthentication_RespondToChallengeMessage', sessionId);\n        }\n    }\n});","import { KeyAgreementParameters } from \"@berytus/types\";\n\nexport interface Channel {\n    id: string;\n    scmEd25519?: {\n        private: ArrayBuffer; // raw pkcs8\n        public: string; // base64 spki\n    };\n    scmX25519?: {\n        private: ArrayBuffer; // raw pkcs8\n        public: string; // base64 spki\n    };\n    webAppEd25519Pub?: string;\n    keyAgreement?: {\n        parameters: KeyAgreementParameters;\n        signatures: {\n            canonicalJson: string;\n            webAppSignature: ArrayBuffer;\n            scmSignature?: ArrayBuffer;\n        };\n    };\n    e2eeActvie: boolean;\n    e2eeKey?: ArrayBuffer;\n}\n\ninterface E2EReadyChannel extends Channel {\n    scmEd25519: NonNullable<Channel['scmEd25519']>;\n    scmX25519: NonNullable<Channel['scmX25519']>;\n    webAppEd25519Pub: NonNullable<Channel['webAppEd25519Pub']>;\n    keyAgreement: NonNullable<Channel['keyAgreement']>;\n}\n\nexport interface E2EChannel extends E2EReadyChannel {\n    e2eeActvie: true;\n    e2eeKey: ArrayBuffer;\n}\n\nexport function isChannelE2EReady(channel: Channel): channel is E2EReadyChannel {\n    return !!(channel.scmEd25519 &&\n        channel.scmX25519 &&\n        channel.webAppEd25519Pub &&\n        channel.keyAgreement &&\n        channel.keyAgreement.signatures.webAppSignature &&\n        channel.keyAgreement.signatures.scmSignature);\n}","import{ generate } from \"do_username\";\nimport { EBerytusFieldType } from \"@berytus/enums\";\n\nexport const randomPassword = () => {\n    const bytes = new Uint8Array(16);\n    window.crypto.getRandomValues(bytes);\n    let blocks: Array<string> = [];\n    const lang = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9']\n    for (let i = 0; i < bytes.length; i++) {\n        const num = bytes[i];\n        blocks[i % 4] = (blocks[i % 4] || \"\") +\n            lang[num % lang.length];\n    }\n    return blocks.join('-');\n}\n\nexport const randomUsername = () => {\n    const suffix = randomPassword().substring(0, 4);\n    return generate(8) + suffix;\n}\n\nexport type BgColor = `bg-${string}`;\n\n\nexport async function randomFieldValue(fieldType: typeof EBerytusFieldType[keyof typeof EBerytusFieldType]): Promise<string | ArrayBuffer> {\n    switch (fieldType) {\n        case EBerytusFieldType.Identity:\n            return randomUsername();\n        case EBerytusFieldType.Password:\n        case EBerytusFieldType.SecurePassword:\n            return randomPassword();\n        case EBerytusFieldType.Key:\n            const genKey = await crypto.subtle.generateKey(\n                {\n                    name: \"RSA-OAEP\",\n                    modulusLength: 4096,\n                    publicExponent: new Uint8Array([1, 0, 1]),\n                    hash: \"SHA-256\",\n                },\n                true,\n                [\"encrypt\", \"decrypt\"]\n            );\n            const privKeyBuf = await window.crypto.subtle.exportKey(\"pkcs8\", genKey.privateKey);\n            return privKeyBuf;\n        default:\n            throw new Error('error: generateStr received an invalid fieldType ' + EBerytusFieldType[fieldType]);\n    }\n}\n\nexport const notEmpty = (str: string | undefined): boolean => {\n    if (str === undefined) {\n        return false;\n    }\n    return str.length > 0;\n}\n\nexport const scrollTopSmooth = () => {\n    window.scrollTo({\n        top: 0,\n        left: 0,\n        behavior: 'smooth'\n    });\n};\n\nexport const concatErrorMessages = (...args: Array<Error | undefined>): string => {\n    let res: Array<string> = [];\n    for (let i = 0; i < args.length; i++) {\n        const err = args[i];\n        if (! err) {\n            continue;\n        }\n        res.push(err.message);\n    }\n    return res.join(' && ');\n}\n\nexport function atLeastOneErrorSet(errors?: Array<Error | undefined>): boolean {\n    if (! errors) {\n        return false;\n    }\n    for (let i = 0; i < errors.length; i++) {\n        if (errors[i]) {\n            return true;\n        }\n    }\n    return false;\n}","const {\n    SEA_LIST,\n    SEA_CREATURES,\n    DESCRIPTORS,\n    COLORS,\n    CREATURE_DESCRIPTORS,\n    ADJECTIVE_DESCRIPTORS,\n    SEA_OBJECTS,\n    SIZE_DESCRIPTORS,\n} = require('./constants');\n\nconst { randomNoun, randomDescriptor, randomColor, format, combineUsername } = require('./private_functions');\n\nconst generate = (maxSize = 30) => {\n    if (maxSize <= 0 || typeof maxSize !== 'number') {\n        throw new Error('The maxSize argument must be an integer number greater than zero.');\n    }\n\n    let noun = randomNoun();\n    let descriptor = randomDescriptor(noun);\n    let color = randomColor();\n\n    noun = format(noun);\n    descriptor = format(descriptor);\n    color = format(color);\n\n    return combineUsername(maxSize, descriptor, color, noun);\n};\n\nmodule.exports = {\n    SEA_LIST,\n    SEA_CREATURES,\n    DESCRIPTORS,\n    COLORS,\n    CREATURE_DESCRIPTORS,\n    ADJECTIVE_DESCRIPTORS,\n    SEA_OBJECTS,\n    SIZE_DESCRIPTORS,\n    generate,\n};\n","const SEA_CREATURES = module.exports.SEA_CREATURES = Object.freeze([\n    'walrus', 'seal', 'fish', 'shark', 'clam', 'coral', 'whale', 'crab',\n    'lobster', 'starfish', 'eel', 'dolphin', 'squid', 'jellyfish', 'ray',\n    'shrimp', 'mantaRay', 'angler', 'snorkler', 'scubaDiver', 'urchin',\n    'anemone', 'morel', 'axolotl',\n]);\n\nconst SEA_OBJECTS = module.exports.SEA_OBJECTS = Object.freeze([\n    'boat', 'ship', 'submarine', 'yacht', 'dinghy', 'raft', 'kelp',\n    'seaweed', 'anchor',\n]);\n\nconst ADJECTIVE_DESCRIPTORS = module.exports.ADJECTIVE_DESCRIPTORS = Object.freeze([\n    'cute', 'adorable', 'lovable', 'happy', 'sandy', 'bubbly', 'friendly',\n    'floating', 'drifting',\n]);\n\nconst SIZE_DESCRIPTORS = module.exports.SIZE_DESCRIPTORS = Object.freeze([\n    'large', 'big', 'small', 'giant', 'massive', 'tiny', 'little',\n]);\n\nmodule.exports.CREATURE_DESCRIPTORS = Object.freeze([\n    'swimming', 'sleeping', 'eating', 'hiding',\n]);\n\nmodule.exports.SEA_LIST = Object.freeze(\n    SEA_OBJECTS.concat(SEA_CREATURES),\n);\n\nmodule.exports.DESCRIPTORS = Object.freeze(\n    ADJECTIVE_DESCRIPTORS.concat(SIZE_DESCRIPTORS),\n);\n\nmodule.exports.COLORS = Object.freeze([\n    'blue', 'blueGreen', 'darkCyan', 'electricBlue', 'greenBlue',\n    'lightCyan', 'lightSeaGreen', 'seaGreen', 'turquoise', 'aqua',\n    'aquamarine', 'teal', 'cyan', 'gray', 'darkBlue', 'cerulean', 'azure',\n    'lapis', 'navy',\n]);\n"],"names":["SEA_LIST","SEA_CREATURES","DESCRIPTORS","COLORS","CREATURE_DESCRIPTORS","require","random","items","Math","length","module","exports","randomNoun","randomDescriptor","noun","includes","concat","format","string","toUpperCase","slice","randomColor","combineUsername","maxSize","descriptor","color","PRIMARY_IDENTITY_ID","PRIMARY_SETTINGS_ID","SecretDexie","Dexie","constructor","super","accounts","sessions","identity","picture","channel","signingKeys","webApp","pendingRequests","settings","this","version","stores","webAppKey","on","async","db","dexieDb","count","add","id","seamless","signup","login","getSettings","get","Error","updateSettings","change","update","_objectSpread","getIdentity","savePicture","f","data","btoa","String","fromCharCode","apply","Uint8Array","arrayBuffer","put","filename","name","type","findCorrespondingAccounts","givenActor","category","filter","_ref","webAppActor","metadata","actorB","actorA","ed25519Key","originalUri","hostname","undefined","matchActors","pictureToDataUrl","PAGECONTEXT_POPUP","indexUrl","_browser","browser","_browser$runtime","runtime","getURL","url","relativePath","appPageContext","startsWith","getSessionRecord","record","sessionId","EOperationType","ERejectionCode","EMetadataStatus","ab2base64","buffer","ab2str","userAttributesLabels","stringifyEncryptedPacket","value","parameters","Object","keys","forEach","key","prop","ArrayBuffer","JSON","stringify","ciphertext","openPageActionPopupIfNecessary","absolutePath","requestId","tabId","pageAction","show","prom0","associateTabIdWithRequest","prom1","tabIdWherePageActionIs","path","relative","arguments","setPopup","popup","setPageActionUrlInTab","prom2","openPopup","tabDictKey","storage","session","set","onMessage","addListener","request","sender","sendResponse","console","log","hide","getAssociatedTabId","Promise","resolve","e","warn","error","remove","deleteTabIdAssociation","send","berytus","resolveRequest","rejectRequest","debug","then","plainContext","context","response","printSessionForSimiluationPrep","phase","showUi","sessionRecordPromise","document","registerRequestHandler","manager","getSigningKey","args","toArray","public","keyPair","window","crypto","subtle","generateKey","publicKey","exportKey","private","privateKey","getCredentialsMetadata","accountConstraints","schemaVersion","createChannel","scmActor","scmEd25519","webAppEd25519Pub","e2eeActvie","generateX25519Key","scmX25519","scmX25519Key","b64Spki","verifySignedKeyExchangeParameters","keyAgreement","obj","parse","canonicalJson","fingerprint","salt","derivation","info","authentication","scm","exchange","importKey","base64","binaryString","atob","bytes","i","charCodeAt","base64ToArrayBuffer","TextEncoder","encode","verify","webAppSignature","reject","GeneralError","signatures","signKeyExchangeParameters","scmSignature","sign","enableEndToEndEncryption","isChannelE2EReady","fromBase64","scmKey","sharedKey","deriveKey","encryptionKey","generation","e2eeKey","closeChannel","approveOperation","_context$channel$cons","_context$channel$cons2","operation","requests","constraints","account","status","Pending","changePassUrl","closeOperation","accountId","randomPassword","getRandomValues","blocks","lang","num","join","Registration","sessionRecord","createdAccountId","date","Date","toISOString","registrationUri","uri","fields","userAttributes","closed","getRecordMetadata","selectedAccountId","updateMetadata","accountCreation","approveTransitionToAuthOp","currSessionId","nextSessionId","newAuthOp","currSessionRecordPromise","currSession","transitionedFromSessionId","getUserAttributes","requiredUserAttributes","map","requestedUserAttributes","required","updateUserAttributes","addField","_sessionRecord$putFie","field","createFieldOptions","find","o","options","putFields","rejectFieldValue","_sessionRecord$fields","_sessionRecord$reject","_sessionRecord$create","fieldId","rejectedFieldValueIndex","rejectedFieldValues","findIndex","optionalNewValue","sameValue","code","reason","webAppDictatedValue","previousValues","push","accountAuthentication","approveChallengeRequest","challengeId","challenge","challenges","messages","abortChallenge","closeChallenge","respondToChallengeMessage","messageId","payload","isView","Array","isArray","ADJECTIVE_DESCRIPTORS","SEA_OBJECTS","SIZE_DESCRIPTORS","generate","freeze"],"sourceRoot":""}