CREATE TABLE berytus_account(
    AccountID BIGINT GENERATED ALWAYS AS IDENTITY,
    CreatedAt TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP NOT NULL,
    PRIMARY KEY (AccountID)
);

CREATE TABLE berytus_account_user_attributes(
    AccountID BIGINT NOT NULl,
    UserAttributeDictionary JSONB NOT NULL,
    CreatedAt TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP NOT NULL,
    PRIMARY KEY (AccountID)
);


-- this table is not write-heavy:
CREATE TABLE berytus_account_def(
    AccountVersion INT GENERATED BY DEFAULT AS IDENTITY,
    CreatedAt TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP NOT NULL,
    PRIMARY KEY (AccountVersion)
);

-- this table is not write-heavy:
CREATE TABLE berytus_account_def_category(
    AccountCategory VARCHAR(256) PRIMARY KEY NOT NULL,
    CreatedAt TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP NOT NULL
);

/*
 * Given a category, return "available" versions that we can
 * create accounts for. If a user tries to create an account with a
 * (category, version) tuple that does not exist in this table,
 * we reject it.
 *
 * Moreover, this would enable several categories to share
 * account versions. E.g., an account category (e.g. Custommer)
 * can choose from one of many account field structures
 * (e.g. username+password or username+key).
 */
CREATE TABLE berytus_account_def_category_version(
    AccountCategory VARCHAR(256) NOT NULL,
    AccountVersion INT NOT NULL CHECK (AccountVersion > 0),
    Description VARCHAR(1024) DEFAULT NULL,
    AllowNewRegistrations BOOLEAN DEFAULT TRUE,
    CreatedAt TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP NOT NULL,
    PRIMARY KEY (AccountCategory, AccountVersion),
    CONSTRAINT fk_badcv_AccountCategory
        FOREIGN KEY (AccountCategory) REFERENCES berytus_account_def_category(AccountCategory),
    CONSTRAINT fk_badcv_AccountVersion
        FOREIGN KEY (AccountVersion) REFERENCES berytus_account_def(AccountVersion)
);

CREATE TYPE EFieldType AS ENUM('Identity', 'ForeignIdentity', 'Password', 'SecurePassword', 'ConsumablePassword', 'Key', 'SharedKey');

-- this table is not write-heavy:
CREATE TABLE berytus_account_def_field(
    AccountVersion INT NOT NULL,
    FieldID VARCHAR(256) NOT NULl,
    FieldType EFieldType NOT NULL,
    FieldOptions JSONB DEFAULT NULL,
    CreatedAt TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP NOT NULL,
    PRIMARY KEY (AccountVersion, FieldID),
    CONSTRAINT fk_badf_AccountVersion
        FOREIGN KEY (AccountVersion) REFERENCES berytus_account_def(AccountVersion)
);

-- This table holds the primary identity fields of an account structure.
-- That is, an array of field ids, e.g., ['accountId', 'name'], is sufficient
-- to retrieve the account id by selecting the maching records in
-- `berytus_account_field`. If all the returned records for (version, fieldIds)
-- correspond to a single account id, we have found our account.
-- this table is not write-heavy:
CREATE TABLE berytus_account_def_key_field_id(
    AccountVersion INT NOT NULL,
    FieldID VARCHAR(256) NOT NULl,
    CreatedAt TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP NOT NULL,
    PRIMARY KEY (AccountVersion, FieldID),
    CONSTRAINT fk_badkfi_AccountVersionFieldID
        FOREIGN KEY (AccountVersion, FieldID) REFERENCES berytus_account_def_field(AccountVersion, FieldID)
);

-- Make sure that each record stored in berytus_account_def_key_field_id corresponds
-- to an IdentityField or ForeginIdentityField. It is not a write-heavy table,
-- so triggers are ok.
CREATE OR REPLACE FUNCTION ensure_key_fields_only() RETURNS TRIGGER AS $$
DECLARE
    t EFieldType;
BEGIN
    SELECT FieldType
    INTO   t
    FROM   berytus_account_def_field
    WHERE  AccountVersion = NEW.AccountVersion
      AND  FieldID = NEW.FieldID
    LIMIT 1;

    IF t IS NULL OR (t <> 'Identity' AND t <> 'ForeignIdentity') THEN
        RAISE EXCEPTION 'Berytus Error: The inserted account key field must correspond to an Identity or ForeignIdentity field. Got %', t;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER berytus_account_def_key_field_id_chk
BEFORE INSERT ON berytus_account_def_key_field_id
FOR EACH ROW
EXECUTE FUNCTION ensure_key_fields_only();

CREATE TABLE berytus_account_field(
    AccountID BIGINT NOT NULL,
    AccountVersion INT NOT NULL,
    FieldID VARCHAR(256) NOT NULL,
    FieldValue JSONB NOT NULL, -- can contain a password hash, private key, public key, email, etc.
    CreatedAt TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP NOT NULL,
    PRIMARY KEY (AccountID, AccountVersion, FieldID),
    CONSTRAINT fk_baf_AccountID
        FOREIGN KEY (AccountID) REFERENCES berytus_account(AccountID),
    CONSTRAINT fk_baf_AccountVersionFieldID
        FOREIGN KEY (AccountVersion, FieldID)
            REFERENCES berytus_account_def_field(AccountVersion, FieldID)
);


CREATE TYPE EChallengeType AS ENUM('DigitalSignature', 'Password', 'SecureRemotePassword', 'OffChannelOtp');

CREATE TABLE berytus_account_def_auth_challenge(
    AccountVersion INT NOT NULL,
    ChallengeID VARCHAR(256) NOT NULL, -- specified by the admin
    ChallengeType EChallengeType NOT NULL,
    ChallengeParameters JSONB DEFAULT NULL,
    CreatedAt TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP NOT NULL,
    PRIMARY KEY (AccountVersion, ChallengeID),
    CONSTRAINT uk_badac_AccountVersionChallengeType
        UNIQUE (AccountVersion, ChallengeType)
);

CREATE TYPE EAuthOutcome AS ENUM('Pending', 'Aborted', 'Succeeded');

CREATE TABLE berytus_account_auth_session(
    SessionID BIGINT GENERATED ALWAYS AS IDENTITY NOT NULl,
    AccountID BIGINT NOT NULL,
    AccountVersion INT NOT NULL,
    Outcome EAuthOutcome DEFAULT 'Pending' NOT NULL,
    CreatedAt TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP NOT NULL,
    PRIMARY KEY (SessionID),
    CONSTRAINT fk_baas_AccountID
        FOREIGN KEY (AccountID) REFERENCES berytus_account(AccountID),
    CONSTRAINT fk_baas_AccountVersion
        FOREIGN KEY (AccountVersion) REFERENCES berytus_account_def(AccountVersion)
);

CREATE TABLE berytus_account_auth_challenge(
    SessionID BIGINT NOT NULL,
    ChallengeID VARCHAR(256) NOT NULL,
    Outcome EAuthOutcome DEFAULT 'Pending' NOT NULL,
    CreatedAt TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP NOT NULL,
    UpdatedAt TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP NOT NULL,
    PRIMARY KEY (SessionID, ChallengeID),
    CONSTRAINT fk_baac_SessionID
        FOREIGN KEY (SessionID) REFERENCES berytus_account_auth_session(SessionID)
);

-- TODO(berytus): add a constraint on ChallengeID
-- to ensure it exists in berytus_account_auth_challenge
CREATE TABLE berytus_account_auth_challenge_message(
    SessionID BIGINT NOT NULL,
    ChallengeID VARCHAR(256) NOT NULL,
    MessageName VARCHAR(256) NOT NULL,
    Request JSONB DEFAULT NULL,
    Expected JSONB DEFAULT NULL, -- E.g., expected OTP code or password hash.
    Response JSONB DEFAULT NULL, -- E.g., the relayed OTP code from the manager.
    StatusMsg VARCHAR(256) DEFAULT NULL, -- 'Ok' | 'Error:*'
    CreatedAt TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP NOT NULL,
    PRIMARY KEY (SessionID, ChallengeID, MessageName),
    CONSTRAINT fk_baacm_SessionID
        FOREIGN KEY (SessionID) REFERENCES berytus_account_auth_session(SessionID)
);

/*
MariaDB [(..)]> SELECT * FROM berytus_account_field_dictionary;
+----------------+-----------+------------------------------------------------------------------------------------+
| AccountVersion | AccountID | FieldList                                                                          |
+----------------+-----------+------------------------------------------------------------------------------------+
|              1 |         1 | {"password":{"salt":"c2beae...","hash":"1cbbf7d45..."},"username":"bob123"}        |
|              2 |         1 | {"securePassword":"securePassBob","username":"bob123"}                             |
|              1 |         2 | {"password":"passjohn","username":"john123"}                                       |
|              2 |         2 | {"securePassword":"securePassJohn","username":"john123"}                           |
|           2000 |        21 | {"partyId":"jerry-and-sons","securePassword":"securePassJerry","username":"jerry"} |
|           2000 |        22 | {"partyId":"jerry-and-sons","securePassword":"securePassCaleb","username":"caleb"} |
|           2000 |        23 | {"partyId":"marks-and-sons","securePassword":"securePassMark","username":"mark"}   |
|           2000 |        24 | {"partyId":"mark-and-sons","securePassword":"securePassMatty","username":"matty"}  |
+----------------+-----------+------------------------------------------------------------------------------------+
*/
CREATE VIEW berytus_account_field_dictionary AS
SELECT  AccountVersion, AccountID,
        jsonb_object_agg(FieldID, FieldValue ORDER BY FieldID) AS FieldList
FROM berytus_account_field
GROUP BY AccountVersion, AccountID
ORDER BY AccountID ASC;

/*
MariaDB [(..)]> SELECT * FROM berytus_account_key_field_dictionary;
+----------------+--------+-------------------------------------------------+
| AccountVersion | AccountID | FieldList                                       |
+----------------+-----------+-------------------------------------------------+
|              1 |         1 | {"username":"bob123"}                           |
|              2 |         1 | {"username":"bob123"}                           |
|              1 |         2 | {"username":"john123"}                          |
|              2 |         2 | {"username":"john123"}                          |
|           2000 |        21 | {"partyId":"jerry-and-sons","username":"jerry"} |
|           2000 |        22 | {"partyId":"jerry-and-sons","username":"caleb"} |
|           2000 |        23 | {"partyId":"marks-and-sons","username":"mark"}  |
|           2000 |        24 | {"partyId":"mark-and-sons","username":"matty"}  |
+----------------+-----------+-------------------------------------------------+
*/
CREATE VIEW berytus_account_key_field_dictionary AS
SELECT  auf.AccountVersion, auf.AccountID,
        jsonb_object_agg(auf.FieldID, auf.FieldValue ORDER BY auf.FieldID) AS FieldList
FROM berytus_account_field AS auf
JOIN berytus_account_def_key_field_id AS akf
    ON akf.AccountVersion = auf.AccountVersion
    AND akf.FieldID = auf.FieldID
GROUP BY auf.AccountVersion, auf.AccountID
ORDER BY auf.AccountID ASC;
